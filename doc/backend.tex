\documentclass[12pt]{article}

\usepackage{array,tabularx}
\newcolumntype{Y}{>{\raggedright\arraybackslash}X}

\renewcommand\gets{\mathrel{:=}}
\newcommand\PAL{\texttt{C-{}-}}
\newcommand\lrtl{\mbox{$\lambda$-RTL}}

\catcode`\$=10
\catcode`\:=10
\markboth{$Revision: 1.9 $}
         {$Revision: 1.9 $}
\newcommand\addtherevision{\\( CVS {$Revision: 1.9 $})}
\catcode`\:=12
\catcode`\$=3 % dollar sign is math shift

\title{Hack Compilers in Your Spare Time?\\
  Build a Back End for Quick~{\PAL}! \addtherevision}
\author{Norman Ramsey}

\begin{document}

\maketitle

{\small
\tableofcontents}

\bigskip

This document describes what needs to be done to add a new back end to
the Quick~{\PAL} compiler.
Until we actually have working back ends, it's a work in progress.

\section{Name the architecture}

Choose a name for your target architecture.
Ideally, you should use the name that the GNU project uses, assuming
you can figure out how to learn it.
In this document, we use the example name \texttt{arch}.

\section{Decide on storage spaces}

\newcommand\inspace[2]{\ensuremath{\$\mathtt{#1}[#2]}}

Decide what storage spaces you will need to represent registers and
memory on the target machines.
We recommend these conventions:\\[3pt]
\begin{tabularx}{\linewidth}{@{\hskip1.5em}ccY@{}}
\emph{H/W}& \emph{Tmp}& \emph{Description}\\
\texttt m& --- & Memory (or data memory)\\
\texttt i& --- & Instruction memory (on a Harvard architecture only)\\
\texttt r& \texttt t& General-purpose or integer registers\\
\texttt f& \texttt u& Floating-point registers\\
\texttt a& \texttt v& Address registers, if any\\
\texttt p& \texttt w& Predicate registers, if any\\
\texttt c& ---      & Control registers and status words (program
counter, etc.).  
If applicable, put PC in \inspace c 0, nPC in \inspace c 1, and condition
codes in \inspace c 2.
We may tentatively consider putting IEEE floating-point rounding modes
in \inspace c 3.
\\
\end{tabularx}\\[3pt]
Only a register-like space has an associated temporary
space.
By convention, spaces \texttt{a}~through~\texttt{s} are ordinary
spaces and \texttt{t}~through~\texttt{z} are for temporary spaces.
If you need more temporary spaces, use \texttt{0}~through~\texttt{9}.

You'll need to document the behavior of these spaces by producing a
\texttt{Space.t list}, which in turn is used to configure the
allocator for temporary variables.
The \texttt{Space} module provides support in \texttt{Space.Standard32}.
If you target a 64-bit machine, please write \texttt{Space.Standard64}.


\section{Lies, damn lies, and abstraction}

Consider what lies you may want to tell the compiler about the
machine.
Such lies involve concealing from the compiler things it need not
know.
\begin{itemize}
\item
You might wish to hide the details of some computation by introducing
a new RTL operator with unspecified semantics.
The name of such an operator should begin with the name of your
architecture, followed by an underscore.\footnote
{Perhaps it would be better to use a dot?}
For example, if I want to conceal just how the condition codes are
updated after an integer comparison, I might define the operator
\texttt{arch\_icmp} and use it in instructions that set condition codes.
For real-life examples, see the \texttt{x86} code expander.
\item
One might wish to conceal the exact representation of some part of the
machine state.
For example, I might wish to pretend that the condition codes occupy a
full 32-bit register.
\end{itemize}
The purpose of telling such lies is to simplify the code expander and
recognizer.
Without some abstraction, it can be hard to write these components by
hand.

\section{Consider the back end}

The major machine-dependent components of the back end are
these:\footnote
{This list deliberately omits components related to calling
conventions, as we don't yet know what we're doing there.}
\begin{itemize}
\item
Variable placer
\item
Code expander
\item
Recognizer
\item
Assembler
\end{itemize}
With luck, you will use a generic variable placer parameterized by
context and a generic code expander parameterized by a
``postexpander.''
All of these
components will require significant effort on your part.

In the long run,
we hope to generate all these components from \lrtl\ and SLED descriptions,
but this technology is still in the research stages.

\section{Choose a representation of instructions}

Choose a representation for instructions to be shared by your
assembler and your recognizer.
In an ideal world, 
we would recommend using the representation generated by the New Jersey
Machine-Code Toolkit. 
Unfortunately, the Toolkit's support for Objective Caml is such that
this representation is usable only if the SLED machine description
scrupulously avoids upper-case letters.
If such is not the case, the assembly-language string itself is a
reasonable stopgap representation.


\section{Ladies and gentlemen, place your variables} 


We hope it will be unnecessary to write a custom variable placer for
each target.
We hope instead to provide a selection of pre-written placers to
choose from:
\begin{itemize}
\item
A generic ``integer/float/address'' placer, which should produce useful
results on a those machines that have data, address, and 
floating-point registers, which is to say, on the 68000.
This placer can also be used on machines without address registers.
The code exists and can be used in Lua code as
\texttt{Placevar.context}. 
It has to be supplied with a machine-dependent context.
\item
A stack placer, which puts each variable on the stack.
I don't know if this is implemented yet, but if not, It could be
implemented easily.
\item
The FORTRAN placer, which places a variable according to the first
letter of its name.
It should not be used except under special circumstances.
\end{itemize}

The \texttt{context} variable placer uses an automaton to place variables in registers;
if a variable cannot be placed in a register, it is placed in the private block on the
stack.
Using the \verb+mk_automaton+ function in \texttt{Placevar.nw}, an
automaton can be created by 
supplying a warning function and an automaton stage for placing variables in
registers.

\section{Write your code expander}

Your code expander must not only establish the machine invariant, but
must also cooperate with your recognizer.
The expander and recognizer need not agree exactly;
it suffices that anything the expander produces, the recognizer can
successfully convert to assembly language.
It is in the expander and recognizer that you are most likely to
exploit any lies (abstractions) you may be telling about the machine.

The two alternatives for an expander are to use Camlburg or the
generic code expander.
An expander written using Camlburg can find and exploit the
addressing modes of the target machine, but writing such an expander
may involve more effort, and more duplication of effort, than writing
an expander that produces only very simple code.
Because we recommend Camlburg for writing a recognizer, further
discussion of Camlburg may be found in Section~\ref{sec:camlburg-rec}.

The generic code expander requires you to implement only very simple
operations: loads and stores, branches, computation on temporaries, and
conditional branches based on comparisons of temporaries.
You implement these operations as part of a \emph{postexpander}, which
is then passed to the generic expander as a module parameter.
The details of the interface are in \texttt{Postexpander.S} as
defined in \texttt{src/expander.nw}.
You can see several examples in the compiler.
\begin{itemize}
\item
The x86 postexpander is a nightmare, because it deals with both
registers and the floating-point stack.
But it is also the only \emph{complete} postexpander we have (in the
sense that it can compile C~programs).
Its sources are in \texttt{src/x86.nw}.
\item
It may also be worth looking at the postexpanders for Alpha or MIPS,
which can be found in \texttt{src/alpha.nw} and \texttt{src/mips.nw}.
These postexpanders support no floating-point stack and so are
slightly simpler---but they implement hardly any instructions.
\end{itemize}
It might also be reasonable to write a code expander by hand, using
the ``maximal munch'' style of ML~pattern matching expounded in Andrew
Appel's compiler text.

\section{Write your recognizer}

Our research group has invested substantial effort in hand-writing and
automatically generating top-down recognizers.
These recognizers operate on the same principles as automata for
ML~pattern matching.
We have learned that top-down matching is poorly suited to the
problem.
Accordingly, we now recommend bottom-up tools.

\label{sec:camlburg-rec}

In the long run, we hope that a special-purpose bottom-up matching
tool can provide special support for commutative operators, possibly
also for
associative-commutative operators, and for
temporaries and kills.
In the short run, we recommend writing a recognizer by hand using
Camlburg.
We suggest that you
\begin{itemize}
\item
Ignore temporaries
\item
Ignore kills except as required by your code expander
\item
Ignore commutativity except perhaps for commutativity of addition in
address arithmetic
\item
Ignore associative-commutative operators
\end{itemize}

\paragraph{Connecting RTLs with BURG constructors}

We recommend that you drive Camlburg with ML~code that changes
the representation of RTL operators.
The main compiler uses a generic representation with a single form of
apply node.
This is a good representation for analysis (e.g., live-variable
analysis) but a poor one for matching.
Since Camlburg requires that you define your own constructors, we
recommend you choose one that gives every RTL operator its own, unique
constructor.\footnote
{One benefit of this representation is that while every BURG
nonterminal has a significant dynamic cost, a BURG constructor has no
dynamic cost.}
For example, to add $e_1$ and $e_2$ using the generic RTL
representation, you would write
$$\texttt{App}((\texttt{"add"}, [w]), [e_1; e_2]).$$
This code could be transformed into the following BURG application:
$$\texttt{Add}(w, e_1, e_2).$$
Alternatively, you could throw away the width and use only 
$\texttt{Add}(e_1, e_2)$.
Whether the width is useful probably depends on the assembly language
of your target machine.
If you use SLED on a machine with multiple widths, the width is
probably useful.

Here is a Caml pattern match that performs this transformation:
\begin{verbatim}
| RP.App(("add", [w]), [x; y]) -> conAdd (exp x) (exp y)
| RP.App(("sub", [w]), [x; y]) -> conSub (exp x) (exp y)
| RP.App(("sx", [n;w]), [x])   -> conSx  (exp x)
| RP.App(("zx", [n;w]), [x])   -> conZx  (exp x)
\end{verbatim}
Further examples can be found in the $x$86 recognizer (\texttt{src/x86rec.nw}).
This recognizer is not for the faint of heart, because it requires a
great deal of nonlinear matching, in which the same value occurs in
multiple places in the tree.
For example, $r_1 \gets r_2 + r_3$ can be part of an instruction only
if $r_1 = r_2$.
Neither ML nor BURG copes well with this situation, and you should be
satisfied if you can avoid running shrieking from the room.


\paragraph{Defining BURG nonterminals}

In any program, the values of some expressions are determined at link
time.
The expression ``\texttt{printf}'' is such an expression, but so is
``\texttt{printf+4}.'' 
On the other hand, an expression such as ``\texttt{printf*main}'' is
almost certainly \emph{not} computable at link time.
An expression computable at link time is called \emph{relocatable}.
Which expressions are relocatable depends on the capabilities of your
assembler and linker.
Most assemblers and linkers can deal with sums and differences of
symbols and integer literals.
Assemblers generated from SLED descriptions may be less capable; the
standard such assembler can deal only with expressions of the form
symbol plus constant.
Keeping in mind
your chosen assembler, you should define a BURG nonterminal
\texttt{reloc} for
``relocatable expression.''

You probably will also want to define a BURG nonterminal for each
significant register class (what Lee Feigenbaum calls a \emph{location
set}). 

\section{Write your assembler}

Generate or write a function that emits textual assembly language for
your instructions.
If you use strings to represent instructions, the emitter is trivial.
The Toolkit can generate an emitter for its representation.

Write your assembler.
It is an implementation of the assembly-language interface defined by
the Objective Caml class type 
\texttt{Asm.assembler} (currently lurking in \texttt{Asm3.assembler}).

Ideally we should create some sort of template or functor to help you
with emission of initialized data.


\section{Sanitize your arithmetic}

If you want to support arithmetic at multiple widths in source
program, you should customize the ``arithmetic widener'' for the
instructions available on 
your target.
Kevin Redwine is working on the widener.
In the fullness of time, he will provide instructions and
examples.

The compiler currently provides no support for splitting arithmetic
(i.e., simulating large arithmetic on a machine with a small word size).

\section{Call your conventions}

You will want to implement the C~calling convention.
You may want one
or more specialized {\PAL} calling conventions.
We don't know how to do this yet.

Choose a default calling convention.
We're not yet entirely clear on everything that this choice must
encompass, but at minimum we need the following:
\begin{enumerate}
\item
Provide automata for passing parameters, results, and continuation parameters.
\item
Which register holds the stack pointer?
\item
What is the invariant governing the alignment of the stack pointer at
calls?
\item
What is the contract with the operating system regarding dynamic
``borrowing'' of locations just below the stack pointer?
\end{enumerate}
Just as we have not yet uncovered the whole story about the calling
convention, we have not yet identified the appropriate technology.


\subsection{Stack-frame layout}

Decide on a stack-frame layout.
Your calling convention may influence your stack-frame layout.
These questions aren't yet resolved.
\begin{itemize}
\item
What are the required blocks in the stack frame?
\item
What is the technology and where does it go?
\item
Does the stack frame stay a fixed size or can it change size during
the lifetime of an activation? 
(I~believe our compiler supports only a frame of fixed size.)
\end{itemize}


\subsection{I~C, You~C}

Implement the local C calling convention, or possibly a subset.


\section{Reserve some global registers}

Develop an automaton for assigning locations to global registers.
This automaton should probably be designed in concert with the calling
conventions.\footnote
{It would be good to have some technology to ensure consistency with
calling conventions, or at least to detect any inconsistency at
compile time.}


\section{Aim at your target}

You have to build a \texttt{Target.t}.
This abstraction is a bit of a mess, but we can break it down by
categories. 
\begin{enumerate} 
\item
The \emph{basic information} is the \texttt{name}, which you've already
chosen, and what I'll call ``metrics:''
\texttt{byteorder}, \texttt{wordsize}, \texttt{pointersize},
\texttt{alignment}, and \texttt{memsize}.
You also announce the floating-point semantics using \texttt{float}.
You probably either use \texttt{"ieee754"} or the name of your
machine. 
\item
You'll announce your \texttt{spaces}.
\item
The first problematic items are \texttt{spill} and \texttt{reload}.
The interfaces to these functions are relics from the days when we
understood things less well than we do now.
A~future interface change will undoubtedly make it easier to write
spill code.
For now, we suggest you copy the code from the $x$86 back end and hope
for the best.
It might work.
\item
Your \emph{control flow} will be straightforward, if you're lucky.
If your machine is sensible, 
you should be able to get \texttt{goto}, \texttt{jump},
\texttt{cutto}, \texttt{call}, and \texttt{branch} by using the functor
\texttt{Mflow.MakeStandard}. 
(As of 17~July~2002, the ``standard'' \texttt{cutto} is bogus.)
\item
\emph{Calling conventions} are not yet developed.
Fake your \texttt{cc} field as best you can.
\item
The remaining items are in some way \emph{questionable}.
For now, imitate an existing target for your \texttt{globals},
\texttt{data\_section}, and \texttt{charset}.
\end{enumerate}


\section{Allocate the rest of your registers}

Select and configure a register allocator.
John Dias will provide instructions and examples for configuring his
graph-coloring register allocator.

\section{Lay out your stacks}

Your back end will need a stack layout, which is defined not in Caml
but in Lua.
For examples, see the \texttt{src/luacompile.nw} file.
This needs to be better documented, but the layout value is a table
that has a function \texttt{fn} and is indexed by calling convention. 
For an explanation of the layout operators, you can
try the rejected PLDI submission ``Custom Calling Conventions for a
Portable Assembly Language.''
\begin{verbatim}
-- this code has never been tested
function layoutfn(self,proc) --- dispatch on cc name
  local fn = self[Stack.ccname(proc)] or layouterror
  return fn(self, proc)
end

X86.layout = { creates='no late consts', fn = layoutfn }

function X86.layout["C"](dummy,proc) --- for a C convention 
    local blocks = Stack.blocks(proc)
    blocks.ra = Block.relative(blocks.vfp, "return address", 4, 4)
    local old, young = blocks.oldblocks, blocks.youngblocks

    old.callee   = Block.overlap(32, "high", old.callee)
    old.caller   = Block.overlap(32, "low",  old.caller)
    young.callee = Block.overlap(32, "high", young.callee)
    young.caller = Block.overlap(32, "low",  young.caller)
    local layout = 
                { old.caller       -- <-- high addresses
                , old.callee
                , blocks.ra
                , blocks.vfp
                , blocks.stackdata
                , blocks.continuations
                , blocks.spills
                , young.caller
                , blocks.sp        -- <-- low addresses 
                , young.callee
                }
    if Debug.stack then
      write('======= using stack layout for C/notail =======\n')
      write('****** cc name = ', Stack.ccname(proc), '\n')
      Debug.showblocks (blocks, {'oldblocks', 'ra', 'vfp',
                                 'stackdata', 'continuations', 'spills',
                                 'youngblocks', 'sp'})
    end
    local block = Block.cat(32, layout)
    Stack.freeze(proc,block)
    return 1
end    

X86.layout["notail"] = X86.layout["C"]

function X86.layout["C--"](dummy,proc)
   ...
end    
\end{verbatim}


\section{Configure your compiler}

If you have written components in Caml, export them into Lua.
For example, the $x$86 back end exports these values:\\
\begin{tabularx}{\linewidth}{@{\hskip1.5em}>{\ttfamily}lY@{}}
Asm.x86& The assembler\\
Expander.x86f&  The expander function\\
Expander.x86&  The expander as a full backplane stage\\
Placevar.x86&  A context for variable placement\\
Targets.x86&  The $x86$ target\\
Widen.x86\_floats& A widener for floating-point arithmetic\\
\end{tabularx}
The export code goes into \texttt{src/lualink.nw}.

Now you can write Lua code to construct a back end for your target.
This code goes into \texttt{src/luacompile.nw}.
Here is an example from August~21, 2003.
\begin{verbatim}
Backend.x86 =     
  { target    = Targets.x86
  , placevars = Placevar.context(Placevar.x86, "x86")
  , widen     = NewBackplane.seq
                   { Widen.x86_floats, Widen.store_const(32),
                     Stages.assert('proper widths') }
  , preopt    = Optimize.remove_nops
  , expand    = Expander.x86
  , liveness  = Liveness.liveness
  , ralloc    = Ralloc.color
  , freeze    = X86.layout
  , rmvfp     = Stages.replace_vfp
  , asm       = Asm.x86
  , emit      = Driver.assemble
  , compile   = Compile.file
  }   
\end{verbatim}
You should be ready to start generating assembly code.
\end{document}

