

\begingroup % for lets and defs, keeps them local

\let\i\mathit
\let\t\texttt
\def\rule#1:#2[#3]#4{\mathit{#1}:#2\;[#3]\;\{#4\}}
\def\fv#1{\mathit{fv}(#1)}

% ------------------------------------------------------------------ 
\section{Rule Normalization}
% ------------------------------------------------------------------ 

In the C implementation of {\small IBURG} the results of a match at
run-time are stored into the subject tree. This implementation strictly
separates the subject tree and the result of a match and therefore no
such possibility exists. This makes the implementation of nested
patterns harder. At runtime, there is no way to find out how a certain
match was constructed. This test, however, is necessary to implement
nested patterns: the nested part of a pattern is essentially a predicate
that looks into the history of a node. Our solution is, to re-write
rules to a \emph{normal form} without nested patterns. This comes at the
price of introducing a new non-terminal for every removed nested
pattern.

For the discussion of normalization let us assume a simplified syntax
for rules and patterns:

\begin{center}
\begin{eqnarray*}
    \i{rule}    & ::= & \rule{t}:{p}[c]{a}\\
    p           & ::= & A(p)\\
                & |   & v:\i{t}\\
                & |   & \t{l}
\end{eqnarray*}
\end{center}

A rule is a 4-tuple of its (nonterminal) type $t$, a pattern $p$, a cost
$c$, and some action $a$. A pattern $p$ is either a variable $v:t$ of type
$t$, a literal \t{l}, or a constructor $A$ with exactly one pattern $p$
as its argument. 

The problematic rules are those with a pattern of the form
$A(B(C(v:t)))$: the argument of $A$ is another constructor $B$. A rule
is in \emph{normal form}, if its pattern has no constructor with another
constructor as argument. In other words, the only allowed argument for a
constructor in a normalized rule is a variable or a literal. Rule
normalization takes a list of rules and rewrites them into an equivalent
list of rules in normal form.

The variables in a pattern $p$ in a rule $\rule{t}:{p}[c]{a}$ are
called the \emph{free variables} of $p$, written as $\vec{v} = v_1,
\dots, v_n = \fv{p}$. They can appear in the cost $c$ and action $a$ of
the rule.

A rule not in normal form has the shape $\rule{t}:{A(B(p))}[c]{a}$. To
bring it into normal form, the sub-pattern $B(p)$ is replaced by a new
variable $v_B:t_B$ of type $t_B$, and its cost and action are modified
to provide the variables $B(p)$ defines. If this is the first time we
remove the sub-pattern $B(p)$, we introduce a new rule that defines the
nonterminal $t_B$. This rule might not be normalized and thus must be
considered subsequently. If we have removed the pattern $B(p)$ before,
$t_B$ is already defined by a new rule and we simply have to find it.

Here is the case where we introduce a new rule to define the nonterminal
$t_B$ by a sub-pattern that we have removed from a rule.

\begin{eqnarray*}
\rule{t}:{A(B(p))}[c]{a} & \Rightarrow &
        \rule{t}:{A(v_B:t_B)}[c]{\mathit{let}~\vec{v}=v_B~\mathit{in}~a}\\
    &&  \rule{t_B}:{B(p)}[0]{\fv{B(p)}}\\
\end{eqnarray*}    

A list of rules are re-written into normal-form by applying the above
transformation to all rules that are not in normal form, and recursively
to all new rules that are generated by these applications.

% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

Function [[rules]] normalizes a list of specification rules. A rule is
normalized, if in its pattern a constructor is never applied to another
constructor.

<<norm.mli>>=
val rules: Spec.rule list -> Spec.rule list
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

The explanation of the normalization algorithm at the beginning of this
module worked with a simplified rule and pattern syntax.  Rules really
have two different kinds of variables (terminal and nonterminal), and
constructors have zero or more arguments, not just one. 

<<norm.ml>>=
module S = Spec
module C = Code

let rcsid = "$Id: norm.nw,v 1.6 2003-08-04 16:49:13 lindig Exp $"
@

A rule is [[normalized]], if its pattern is not a constructor
application ([[Con]]), or if no argument of a constructor application is
itself a constructor application.

<<norm.ml>>=
let normalized rule =
    let simple = function
        | S.Con  _ -> false
        | _        -> true 
    in match rule.S.pattern with
        | S.Con(_,args) -> List.for_all simple args
        | _             -> true 
@        

For generating new variables and their types we need a generator. An
identifier in a specification must start with a character. To avoid name
clashes with existing names, generated names start with an underscore
character. 

Function [[mkgen]] returns a name generator that generates names with a
user-supplied prefix; [[genty]] is a generator created by [[mkgen]] for
new nonterminals.

<<norm.ml>>=
let mkgen (n:int ref) = fun (prefix:string) ->
    let k = !n in
        ( n := k+1
        ; "_" ^ prefix ^ string_of_int k 
        )

let genty  = mkgen (ref 1)  (* global generator for nonterms *)
@

New rules are introduced for complex patterns in argument positions in
other patterns. When the same complex pattern appears twice in a rule
set we must avoid to create two new rules. Therefore, new rules are
remembered in a map that associates the pattern of the new rule with its
nonterminal.

<<norm.ml>>=
module Types = Map.Make(struct type t=S.pattern let compare=S.cmp end)
@

If a new rule is introduced, its semantic action returns a tuple of
the free variables found in its pattern. This tuple is matched by a
let-binding in the code of the original rule. Both [[tuplepat]] and
[[tupleval]] help to create such tuples from list of strings.

<<norm.ml>>=
let tuplepat = function 
    | [p] -> C.Var(p) 
    | ps  -> C.Con("", List.map (fun p -> C.Var(p)) ps) 

let tupleval = function [p] -> C.id p   | ps -> C.Tuple(List.map C.id ps)   
@


Normalization is driven by the arguments of a constructor in a
non-normalized rule. If such an argument is itself a constructor, it is
replaced by a variable. The [[norm]] function does this for a single
argument [[arg]]. [[Norm]] receives the name of the outermost rule's
constructor [[c]], the argument [[arg]], a triple with arguments, the
current code, and the list of current rules.

[[Norm]] returns a triple: it puts the replacement for [[arg]] at
the head of the list of arguments, code wrapped by a let-binding into
the second component, and newly introduced rules into the last. 

If the current argument [[arg]] needs to be replaced, a rule for [[arg]]
might or might not have been created. If a rule exists, it is in
[[types]], otherwise a new rule for a new non-terminal is added. In any
case a new variable with the type of the new rule replaces [[arg]]

The free variables in [[arg]] are bound by a [[let]]-binding that wraps
the old [[code]]. A new rule defining [[t]] is introduced; its semantic
action is to return all free variables found in [[arg]] as a tuple.

<<norm.ml>>=
let norm genvar (args, code, rules, types) arg = match arg with
    | S.Con(c,_) as pattern  -> 
        let v       = genvar "v" 
        and vars    = S.freevars arg
        in if Types.mem arg types then
            let t = Types.find arg types 
            in
                ( S.Var(v,S.NonTerm t) :: args          (* normalized arg *)
                , C.Let ([tuplepat vars, C.id v], code) (* wrapped code   *)
                , rules                                 (* old rules *)
                , types                                 (* same types *)
                )
        else
            let t     = genty c in      (* new nonterminal *)
            let rule  = 
                { S.nonterm = t         (* create new rule *)
                ; S.pattern = pattern
                ; S.cost    = C.Int(0)
                ; S.code    = tupleval vars
                } 
            in 
                ( S.Var(v,S.NonTerm t) :: args          (* normalized arg *)
                , C.Let ([tuplepat vars, C.id v], code) (* wrapped code   *)
                , rule :: rules                         (* add rule *)
                , Types.add arg t types                 (* add type of rule *)
                )
    | x           -> (x :: args, code, rules, types)    (* arg is normalized *)
@    

The normalization of a single rule returns the rule in normal form,
and a list of new rules which must be normalized subsequently. Only a
rule with a constructor pattern can violate the normal form. The number
of new rules is at most the arity of the constructor.

The normalization itself is done by folding [[norm]] over all
constructor arguments. It receives and returns a triple: the first
argument is the reversed list of new constructor arguments that replace
the current list, the second is the new code for the current rule, and
the third is the list of new rules. Initially the list of new
arguments and rules are empty, and the current code from the rule is
passed. 

<<norm.ml>>=
let normalize types rule =
    match rule.S.pattern with
    | S.Con (c,args) -> 
        let genvar = mkgen (ref 1) in   (* rule-local var generator *)
        let (args, code, rules, types) = 
            List.fold_left (norm genvar) ([],rule.S.code,[],types) args 
        in
            { rule with
                S.pattern = S.Con(c, List.rev args)
            ;   S.code    = code  
            }, rules, types
    | _ (* normalided *) -> (rule, [], types)
@

We normalize a list of rules with [[rules]]. If we find a rule not in
normal form we pass it to [[normalize]]. This function returns the
normalized rule and a list of new, possibly not normalized, rules.
During the whole process we maintain a map [[types]] that associates for
every new rule the nonterminal it defines.

<<norm.ml>>=
let rules rs = 
    let rec loop types = function
    | []                      -> []
    | r::rs when normalized r -> r :: loop types rs
    | r::rs                   -> let (r',rs', types) = normalize types r in
                                     r' :: loop types (rs' @  rs)
    in
        loop Types.empty rs
@    

\endgroup


