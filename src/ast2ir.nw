% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% vim: ts=8 sw=4 et sts=4
% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon

%%Grades: C Central Immediate

% inc: \usepackage{alltt}


WORK STILL TO BE DONE:
\begin{itemize}
\item
RECORD SET OF THINGS DEFINED AT THE ``UNWOUND TO'' ENTRY POINT OF A CONTINUATION.
THERE IS A PROBLEM HERE, BECAUSE WE HAVE NO WAY TO RECORD
A DEFINITION OF A VARIABLE, BUT THIS IS WHAT THE UNWIND OPERATION
DOES.
PERHAPS THE ASSERTION NODE WILL DO THE TRICK.
\end{itemize}



@
% ------------------------------------------------------------------ 
\section{Translation to Intermediate Representation}
% ------------------------------------------------------------------ 

This module does \emph{lots} of translation: 
each procedure to a [[Proc.t]], and everything else down to the
assembly level.
The [[Proc.t]] is embedded into the assembly program as a single
instruction. 

We put the [[Target.t]] parameter first always because we first put
the less-specific information before the more-specific information.

We have to tie a horrible knot for the recursive types [[Proc.t]] and [[Target.t]].
We introduce type synonyms here that are used in several other modules of the compiler.
<<type imports>>=
type tgt = Preast2ir.tgt = T of (basic_proc, (Rtl.exp -> Automaton.t), Call.t) Target.t
and basic_proc = Preast2ir.basic_proc
type proc      = Preast2ir.proc
type old_proc  = Preast2ir.old_proc
<<ast2ir.mli>>=
<<type imports>>
val set_headroom : int -> unit
val translate : tgt
                -> proc Fenv.Clean.env'
                -> optimizer: (proc -> unit)
                -> defineglobals: bool
                -> proc Nelab.compunit
                -> unit   (* side-effects the assembler in the environment *)
@

% ------------------------------------------------------------------ 
\section{Implementation: Translate to intermediate representation}
% ------------------------------------------------------------------ 

\subsection{Abbreviations, utilities, and type definitions}

We use these abbreviations.
<<ast2ir.ml>>=
module A  = Ast
module AT = Automaton
module C  = Call
module Dn = Rtl.Dn
module E  = Error
module F  = Fenv.Clean
module FE = Fenv
module G  = Zipcfg
module N  = Nelab
module R  = Rtl
module RO = Rewrite.Ops
module RP = Rtl.Private
module RU = Rtlutil
module RS = Register.Set
module RSX= Register.SetX
module S  = Elabstmt
module SM = Strutil.Map
module SP = Spans
module T  = Target
module Up = Rtl.Up
module W  = Rtlutil.Width

type aligned = int
type label   = G.uid * string 
let genlabel s =
  let s = Idgen.label s in
  (G.uid (), s)
@ 
Utility functions and so on.
<<ast2ir.ml>>=
<<utilities>>
@ 
We have a problem with register sets.
Formerly, we mostly kept sets of registers, but for liveness analysis,
we went finer grain and tracked slices.
Crossing this boundary seemed to be expensive, so we move the crossing
here, to the creation of the flow graph.
From here down, the flow graph works with slices.
<<utilities>>=
let rsx = Register.rset_to_rxset
@ 
Here are 
some of the usual suspects.
<<utilities>>=
let (<<) f g  = fun x -> f (g x) (* function composition *)
let impossf x = Printf.kprintf Impossible.impossible x
let unimpf x = Printf.kprintf Impossible.unimp x
@ 
The [[**>]] function is an infix, right-associative function that
makes it easy to create sequences of flow-graph nodes.
(I'm always amazed at how useful it is to have an infix,
right-associative form of the identity function.)
<<utilities>>=
let ( **> ) f x = f x
@
Some of these type definitions are called for in the interface; others
are internal.
The types in module [[K]] are used to translate continuations.
<<ast2ir.ml>>=
<<type imports>>
<<module [[K]], for continution info>>
<<types for nonvolatile registers>>
@ 
\subsection{Overall structure of the translation}

The translator has two major layers: the top-level layer, shown
here, and the single-procedure layer, shown in chunk
[[<<definition of [[proc]], which translates one procedure>>]].
Each layer comes with its own scope; we have top-level scope and
procedure scope. 
The denotation of an expression depends on what scope it's in, but we
prefer \emph{not} to pass a scope or environment everywhere.
Instead, we define a higher-order function [[exprfuns]], which gets
the scope information and returns three functions: [[expr]], 
[[typed_expr]], and [[lvalue]].
We use [[exprfuns]] to instantiate these three functions in two places:
once at top level and once inside each procedure.
The first instantiation is visible here; the second appears in 
[[<<definition of [[proc]], which translates one procedure>>]].
<<ast2ir.ml>>=
(* I have to choose the value  *)
let headroom = ref 1024 
let set_headroom n = headroom := n
<<definition of type [[blocklists]]>>
let translate target env ~optimizer ~defineglobals =
  let T target = target in
  let pointersize = target.T.pointersize in
  let asm = F.asm env in
  <<environment-independent support for formals, actuals, and results>> in
  <<definition of [[proc]], which translates one procedure>> in
  <<definition of [[globals]]>> in
  <<function [[datum]], for initialized and uninitialized data>> in
  <<function [[program]], which translates an entire program>> in
  program
@
% ------------------------------------------------------------------
\subsection{The translation of actual parameters, formal parameters, and results}
% ------------------------------------------------------------------ 

For actuals, formals, or results, we need a sequence of
kind/width/alignment triples
to feed to the calling convention.
For a formal or result, we need the corresponding location, and for each
actual, the corresponding value.
We do the dirty work with a higher-order function.
Argument [[kind_parm_aligned]] splits the abstract syntax into a kind, 
a ``parameter'', and an alignment.
Argument [[cvt]] takes a ``parameter'' and produces a converted
parameter (location or expression), plus the width of the parameter.
The later parameter [[conv]] is a calling convention, which we apply
here for convenience.
THIS OLD FUNCTION MAY BE SLATED FOR REPLACEMENT!!!
<<environment-independent support for formals, actuals, and results>>=
let convert_parms kind_parm_aligned cvt =
  let add x (wkas, parms) =
    let kind, parm, a = kind_parm_aligned x in
    let parm, w = cvt parm in
    (w, kind, a) :: wkas, parm :: parms in
  fun conv l ->
    let hws, parms = List.fold_right add l ([], []) in
    conv hws parms 
@ 
We instantiate this code four ways.
For an actual parameter, the [[cvt]] parameter is the function [[ew]],
which compiles an AST expression into an RTL expression plus a width.
For a formal parameter or result, we use [[lvalue_name_in_env]].
The environment must be a parameter, since we don't have it at the
time these functions are defined.
@
\subsection{The translation of continuations and flow annotations}

\label{ast2ir.sec:cont-trans}

Historically, 
we needed three passes to translate continuations.
THIS NUMBER CAN PROBABLY BE REDUCED, BUT WE HAVEN'T GOT AROUND TO IT YET.
IN ANY CASE, THIS EXPLANATION IS ALMOST CERTAINLY OBSOLETE.
\begin{enumerate}
\item
The first pass finds each continuation and builds the first part of
its translation: representation, labels, and incoming-parameter
handling.
\item
The second pass, which is the main translation of a procedure, 
identifies the code point (flow-graph node) associated with each
continuation in the source code.
\item
The third pass checks how each continuation is used and adds
flow-graph code as needed to implement that continuation.
It also inserts any initializations that are needed.
\end{enumerate}
@
Here is the information we accumulate about each continuation.
There are potentially three entry points into a continuation: by cut,
by unwind, and by alternate return.
We eagerly assign a label to each potential entry point, even though
not every entry point is necessarily needed.
We provide mutable fields so that the second pass can track how a
continuation is actually used and therefore know which entry points
are needed.
If an entry point is needed, the third pass of translation ensures
that the
relevant label is associated with real flow-graph nodes that do
things.

When we encounter a continuation, we also have its formal parameters,
so we run the calling convention, again knowing that we may not need
the results.
We also compute the representation of the continuation in case it is
cut to or it escapes.
The [[return_pcs]] field is needed because 
potentially each calling convention puts the overflow parameters in a
different place (or adjusts the stack differently), so therefore we
need to return to a different lable for each calling convention.
\nextchunklabel{ast2ir.K.t}%
<<module [[K]], for continution info>>=
module K = struct
  type convention = string
  type 'i t =
    {         unwind_pc   : label       (* uids may or may not be used *)
    ;         unwind_sp   : Rtl.loc
    ;         cut_pc      : label
    ; mutable return_pcs  : (convention * label list) list
    ;         escapes     : bool        (* properties of how it is used *)
    ;         cut_to      : bool
    ;         unwound_to  : bool
    ;         formals     : (string * FE.variable * aligned) list
                            (* args (kind, variable index) to the continuation *)
    ;         cut_in      : (Block.t -> Rtl.rtl) C.answer
                                                (* move vals at cut (uses rep) *)
    ;         return_in   : (Block.t -> Rtl.rtl) C.answer
                                                (* move vals at also returns *)
    ;         rep         : Contn.t     (* representation as C-- value (incl block) *)
    ;         base        : Block.t     (* base address; to be composed with rep *)
    ;         convention  : string
    ;         succ        : label       (* filled in by 2nd pass time *)
    ; mutable spans       : (Bits.bits  * Reloc.t) list
                            (* user-defined spans at the continuation *)
    }
  <<definition of [[K.mk]], which initializes continuation information>>
end
@
\subsubsection{First-pass translation of continuations}

Our state of knowledge when we first encounter a continuation.
<<definition of [[K.mk]], which initializes continuation information>>=
let mk to_cc name den rep base ~formals ~cut_in ~return_in ~unwind_sp =
  let ccname cc = (to_cc cc).C.name in
  { escapes     = den.FE.escapes
  ; cut_to      = den.FE.cut_to
  ; unwound_to  = den.FE.unwound_to
  ; unwind_pc   = genlabel "unwind_entry"
  ; unwind_sp   = unwind_sp
  ; cut_pc      = genlabel "cut_entry"
  ; return_pcs  = <<set the return pcs>>
  ; rep         = rep
  ; base        = base
  ; convention  = den.FE.convention
  ; formals     = formals
  ; cut_in      = cut_in
  ; return_in   = return_in
  ; succ        = genlabel "start of continuation code"
  ; spans       = []
  }
@ 
The unfortunate state of affairs is that we must generate an alternate return
entry point for each call site that may make an alternate return to a continuation.
To ensure that each entry point is used only once, we only add an entry label when
we encounter each call site that makes an alternate return to this continuation.
<<set the return pcs>>=
List.map (fun cc -> (ccname cc,[])) den.FE.returned_to
@
<<definition of [[K.mk]], which initializes continuation information>>=
let get_return_pc cc k =
  let labels = try List.assoc cc.C.name k.return_pcs
               with Not_found -> impossf "Unknown alt-return convention %s" cc.C.name in
  let new_label = genlabel "return_entry" in
  let new_entry = (cc.C.name, new_label :: labels) in
  k.return_pcs <- new_entry :: (List.remove_assoc cc.C.name k.return_pcs);
  new_label
@
It's a simple matter of finding the calling convention, running the
automata, and building the rep and the continuation.
<<function [[extend_cont]], for adding flow-graph info to continuations>>=
let extend_cont name den = 
  let cc        = Call.get_cc target den.FE.convention in
  let args      = den.FE.formals in
  let cut_in    = cformals cc.C.cut_parms.C.in' args in
  let return_in = cformals cc.C.results.C.in'   args in
  let rep       = Contn.with_overflow target cut_in.C.overflow in
  K.mk (Call.get_cc target) name den rep den.FE.base ~formals:args ~cut_in ~return_in
       ~unwind_sp:(to_mloc proc_cc.C.stable_sp_loc) in
@
\subsubsection{Second pass: continuations and flow annotations}
The second pass fills in the mutable fields.
First, when we encounter the statement for the second time, we set its
successor.
We return an illegal node since nothing may fall through to a continuation.
<<supporting functions for translating statements>>=
let rec contStmt2 label succ =
  let k = continuation label in
  k.K.spans <- props;
  G.forbidden m **>
  G.label m k.K.succ **>
  succ
@ 
As continuations appear in flow annotations, we set the [[cut_to]],
[[unwound_to]], and [[returned_to]] fields as needed.
We use the labels stored with the continuation to associate the
correct entry point with 
each continuation, depending on how the continuation is used.
This code appears in a context in which the [[continuation]] function
looks up a continuation by name.
<<function [[continuations]], which translates flow annotations>>=
let continuations cc ast =
  let volregs = cc.C.volregs in                 (* volatile registers *)
  let allregs = RS.union volregs cc.C.pre_nvregs in (* all registers *)
  let (--)    = RS.diff in
  let as_cut_to k =
    let defs  = k.K.cut_in.C.regs in
    { G.defs  = rsx defs; G.kills = rsx (allregs -- defs); G.node = k.K.cut_pc
    ; G.assertion = k.K.cut_in.C.insp (Contn.rep k.K.rep) } in
  let as_unwinds k =
    { G.defs  = RSX.empty; G.kills = rsx volregs; G.node = k.K.unwind_pc
    ; G.assertion = proc_cc.C.sp_on_unwind proc_cc.C.stable_sp_loc } in
    (* defs are vars and so can't be a register set. See [[splice_in_unwind_to_entry]] *)
  let as_returns k =
    let pc = K.get_return_pc cc k in
    let defs  = k.K.return_in.C.regs in
    { G.defs  = rsx defs; G.kills = rsx (volregs -- defs); G.node = pc
    ; G.assertion = k.K.return_in.C.insp k.K.return_in.C.overflow } in
  let contmap f = List.map (f << continuation) in
  { S.cuts     = contmap as_cut_to  ast.S.cuts;
    S.unwinds  = contmap as_unwinds ast.S.unwinds;
    S.areturns = contmap as_returns ast.S.areturns;
    S.returns  = ast.S.returns; S.aborts = ast.S.aborts; } in
let ccontinuations cc ast =
  let ast' = { S.cuts = ast.S.ccuts; S.aborts = ast.S.caborts;
               S.unwinds = []; S.areturns = []; S.returns = false; } in
  let c = continuations cc ast' in
  { S.ccuts = c.S.cuts; S.caborts = c.S.aborts }
@
\subsubsection{Third pass: code for initializing and entering continuations}
@ 
The rest of the compilation happens at the end of the procedure.
There are three steps:
\begin{itemize}
\item
Store spans at each escaping continuation (for use by the runtime system).
\item
Initialize any escaping continuations ([[insert_init_cont_nodes]])
\item
Compile entry points for continuations as needed ([[finish_compiling_continuation]])
\end{itemize}
@
For each continuation we have reserved memory on the stack that must be
initialized when the procedure is entered. The following function
inserts code to do the initialization.

We also attach spans to each continuation that escapes.
<<definition of [[insert_init_cont_nodes]]>>=
let insert_init_cont_nodes contmap init_label g =
  let one_node cname k g = 
    if k.K.escapes then
      let pc    = exp_of_code_label k.K.cut_pc in
      let sp    = proc_cc.C.stable_sp_loc      in
      let spans = SP.to_spans ~inalloc ~outalloc:(to_mloc sp) ~ra:saved_ra
                              ~users:k.K.spans ~csregs:nvr_temps ~conts:[]
                              ~sds:sd_locs ~vars:(var_array ()) in
      let cut_g = G.focus (fst k.K.cut_pc) (G.unfocus g) in
      let () = G.set_spans cut_g spans in
      let blockname block =
        match G.Rep.blocklabel block with
        | Some (_, s) -> s
        | None -> "<entry block>" in
      let _focused_blockname g =
        let b, _ = G.openz g in
        let b = G.Rep.zip b in
        blockname b in
      let pc_sp = { Mflow.new_pc = pc; Mflow.new_sp = sp } in
      let init = G.instruction (Contn.init_code k.K.rep pc_sp) (G.entry G.empty) in
      G.splice_focus_entry g (G.unfocus init)
    else
      g in
  G.unfocus (Strutil.Map.fold one_node contmap (G.focus (fst init_label) g))
@ 
When we finish compiling a continuation, we make sure any label that
is used leads to sensible code.
A continuation that escapes but is never cut to presents a dilemma: 
it has to have a value (because it escapes), but the front end has
promised never to use that value in a [[cut to]].
As per discussion including Simon and Norman in the restaurant of Washington DC's 
Melrose Hotel, an continuation that is not [[cut to]] should not be used -- and
therefore, it should not even escape.
This error should really be detected elsewhere.
<<functions that translate statements, including [[stmts]]>>=
let rec finish_compiling_continuation k g =
  let g = 
    if k.K.cut_to then
      splice_in_cut_to_entry k g
    else if k.K.escapes then
      impossf "Continuation escapes but is not annotated with also cuts to"
    else g in
  let g = splice_in_return_to_entries k g in
  let g = if k.K.unwound_to then splice_in_unwind_to_entry k g else g in
  g
@ 
If we cut to a continuation, the overflow parameters live in its
representation on the stack, so we need only shuffle and manage the
stack pointer.
(I really don't believe this any more.  We need to visit the big
picture of continuations.)
\begin{itemize}
\em
\item
Multiple entry points
\item
What prolog for each entry point
\item
When each prolog is inserted into the graph
\end{itemize}
<<functions that translate statements, including [[stmts]]>>=
and splice_in_cut_to_entry k g =
  let in' = k.K.cut_in in
  let prolog =
    G.label m k.K.cut_pc **>
    G.stack_adjust in'.C.pre_sp   **>
    G.instruction  in'.C.shuffle  **>
    G.stack_adjust in'.C.post_sp  **>
    G.branch m k.K.succ     **>
    G.entry G.empty in
  G.add_blocks g prolog
@ 
If we return to a continuation, we must remember the overflow block.

When we unwind, the argument variables are set by the run-time system's unwinding code;
we just need to worry about setting the stack pointer.
<<functions that translate statements, including [[stmts]]>>=
and splice_in_return_to_entries k g = 
  let gen cc g label =
    let in' = k.K.return_in in
    let ()  = add youngblocks cc.C.overflow_alloc.C.result_allocator in'.C.overflow in
    let prolog =
      G.label m label **>
  (* NR IS BEHIND THE TIMES AND NEEDS TO BE REMINDED WHAT HAPPENED TO ASSERTIONS *)
  (* WE LOST:  G.assertion    g (in'.C.insp in'.C.overflow)    *)
      G.stack_adjust in'.C.pre_sp    **>
      G.instruction  in'.C.shuffle   **>
      G.stack_adjust in'.C.post_sp   **>
      G.branch m k.K.succ     **>
      G.entry G.empty in
    G.add_blocks g prolog in
  let gen_labels g (ccname, labels) =
    List.fold_left (gen (Call.get_cc target ccname)) g labels in
  List.fold_left gen_labels g k.K.return_pcs
@ 
When we unwind, the argument variables are set by the run-time
system's unwinding code. 
It is not possible to represent this fact by [[defs]] on the relevant
control-flow edge, because the things being defined are {\PAL}
variables, and the only things we can put on a [[defs]] edge are
registers.

\begin{quote}
In an earlier version on the compiler, to ensure that each formal
parameter had a location, 
we asserted, for each variable, an assignment of that variable to a
bogus location. 
But now instead, we plan to revise the run-time system to do nothing
if a particular formal happens to be dead.

A more serious question, not solved, is what to do about reaching
definitions when variables can be mutated by the run-time system.
\end{quote}
<<functions that translate statements, including [[stmts]]>>=
and splice_in_unwind_to_entry k g = 
  let prolog =
    G.label m k.K.unwind_pc **>
  (* NR IS BEHIND THE TIMES AND NEEDS TO BE REMINDED WHAT HAPPENED TO ASSERTIONS *)
  (* WE LOST: G.assertion g (proc_cc.C.sp_on_unwind proc_cc.C.stable_sp_loc) **> *)
    G.branch m k.K.succ     **>
    G.entry G.empty in
  G.add_blocks g prolog
(*
  let bogus_space = ('z', Rtl.Identity, Cell.of_size 1) in
  let use_var (h,v,a) succ =
    let w = RU.Width.loc v.FE.loc in
    G.assertion g (RU.store (R.mem R.none bogus_space (R.C w)
                                   (R.bits (Bits.S.of_int 0 w) w))
                            (R.fetch (R.var "" v.FE.index w) w)) succ in
  ... (List.fold_right use_var k.K.formals k.K.succ) ...
*)
@

% ------------------------------------------------------------------ 
\subsection{Translations of statements}

@ 
\subsubsection{Simple statements}

We do the simple statements inline,
but interprocedural control flow is complicated enough to warrant
out-of-line functions (as will [[switch]]).
<<functions that translate statements, including [[stmts]]>>=
and stmts props ss succ = List.fold_right (stmt props) ss succ
and _stmt' props s  succ =
  Printf.eprintf "Translating %s\n" (
  match s with
  | S.If (e, so, not) -> "If"
  | S.Label n              -> "Label " ^ n
  | S.Switch _             -> "Switch"
  | S.Cont (name, _, _)    -> "Cont"
  | S.Span (kv, bs)        -> "Span"
  | S.Assign rtl           -> "Assign"
  | S.Call  (lhs, cc, e, args, targets, conts, alias) -> "Call"
  | S.Call' _                                         -> "Call'"
  | S.Goto (e, labels) -> "Goto"
  | S.Jump  (cc, e, args, targets)  -> "Jump"
  | S.Cut (cc, k, args, conts)      -> "Cut"
  | S.Return (cc, i, n, args)       -> "Return"
  | S.Limitcheck (cc, cookie, cont) -> "Limitcheck");
  stmt props s succ
<<functions that translate statements, including [[stmts]]>>=
and stmt  props s  succ =
  <<supporting functions for translating statements>> in
  match s with
  | S.If (e, so, not)      ->
      let cb ~ifso ~ifnot = G.cbranch m e ~ifso ~ifnot in
      G.if_then_else m cb ~t:(stmts props so) ~f:(stmts props not) succ
  | S.Label n              -> G.label m (uid_of n, n) succ 
  | S.Switch (rg, e, arms) -> switchStmt rg e arms props succ
  | S.Cont (name, _, _)    -> contStmt2 name succ
  | S.Span (kv, bs)        -> stmts (kv :: props) bs succ
  | S.Assign rtl           -> G.instruction rtl succ
  | S.Call  (lhs, cc, e, args, targets, conts, alias) ->
      call lhs cc e args targets conts alias succ
  | S.Call' (cc, e, args, targets) ->
      jump ~stack:false cc e args targets succ
  | S.Goto (e, labels) ->
      (match Dn.exp e with
      | RP.Const (RP.Link (sym, _, w)) ->
          let lbl = sym#original_text in
          G.branch m (uid_of lbl, lbl) succ
      | _ -> (*let instr   = machine.T.goto.T.embed e in*)
             let targets = List.map (fun l -> (uid_of l, l)) labels in
             G.mbranch m e targets succ)
  | S.Jump  (cc, e, args, targets)  -> jump ~stack:true cc e args targets succ
  | S.Cut (cc, k, args, conts)      -> cut cc k args conts succ
  | S.Return (cc, i, n, args)       -> return cc i n args succ
  | S.Limitcheck (cc, cookie, cont) -> limitcheck cc cookie cont
@
\paragraph{[[switch]] statements}

We compile a switch statement into a simple sequence of if-then-else
tests, so there's no use for the optional range.
If we were to compile into jump tables, then the optional range might
tell us how big the jump tables would have to be.
N.B.~For efficiency, we rely on [[disjoin]] being suitably short-circuited.
<<supporting functions for translating statements>>=
and switchStmt range e arms props stmt_succ =
  let w = RU.Width.exp e in
  let e_in_interval (lo, hi) =
    if Bits.Ops.eq lo hi then
      RO.eq w e (Rtl.bits lo w)
    else
      RO.conjoin (RO.leu w (Rtl.bits lo w) e) (RO.leu w e (Rtl.bits hi w)) in
  let endswitch, g = G.make_target m stmt_succ in
  let default,   g = G.make_target m (G.forbidden m g) in
  let do_arm (ranges, body) (next_test, g) =
    let condition =
      Simplify.exp (
        List.fold_left (fun cond range -> RO.disjoin (e_in_interval range) cond)
                       (Rtl.bool false) ranges) in
    let arm, g = G.make_target m (stmts props body (G.branch m endswitch g)) in
    G.make_target m (G.cbranch m condition ~ifso:arm ~ifnot:next_test g) in
  let (first_test, g) = List.fold_right do_arm arms (default, g) in
  g
@
\subsubsection{Statements that go between procedures}

\paragraph{Jumps}
The outgoing overflow parameters passed by a tail call go into the
\emph{young} end of the current activation.
N.B.~We don't use the [[targets]] list, which is there for future
interprocedural optimization and call-graph analysis.
<<supporting functions for translating statements>>=
and jump ~stack cconv e args targets g = 
    let stack_adjust = if stack then G.stack_adjust else fun _ succ -> succ in
    let cc      = Call.get_cc target cconv in
    let out     = actuals cc.C.call_parms.C.out args in
    let ra_out  = cc.C.ra_on_exit saved_ra out.C.overflow temps in
    let jump_sp = cc.C.sp_on_jump out.C.overflow temps in
    let () = add oldblocks cc.C.overflow_alloc.C.parameter_deallocator out.C.overflow in
    stack_adjust   out.C.pre_sp                                  **>
    G.instruction  out.C.shuffle                                 **>
    G.instruction  restore_nvrs                                  **>
    G.instruction  (RU.store ra_out (RU.fetch saved_ra))         **>
    G.instruction  (RU.store cc.C.jump_tgt_reg e)                **>
    stack_adjust   jump_sp                                       **>
    G.jump         m (RU.fetch cc.C.jump_tgt_reg) ~targets
                   ~uses:(rsx (RS.union out.C.regs nvregs)) **>
    g
@
\paragraph{Calls}
<<supporting functions for translating statements>>=
and call lhs cconv e args _targets conts alias succ = 
  let cc    = Call.get_cc target cconv in
  let out   = actuals cc.C.call_parms.C.out args in
  let in'   = results cc.C.results.C.in' lhs     in
  let unwind_conts =
    let f_to_cont (h,v,a) = (h,v.FE.index,a) in
    let unwind_k kname =
      let k = continuation kname in
      let args = List.map f_to_cont k.K.formals in
      (k.K.unwind_pc, k.K.unwind_sp, args) in
    List.map unwind_k conts.S.unwinds in
  let conts = continuations cc conts in
  add youngblocks cc.C.overflow_alloc.C.parameter_deallocator out.C.overflow;
                                        (* outgoing overflow parms *)
  add youngblocks cc.C.overflow_alloc.C.result_allocator      in'.C.overflow;
                                        (* incoming overflow results *)
  let outalloc = match cc.C.overflow_alloc.C.parameter_deallocator with
    | C.Caller -> to_mloc (young_end cc out.C.overflow)
    | C.Callee -> to_mloc (old_end   cc out.C.overflow) in
  let label ((uid, l), x, y) = (l, x, y) in
  let spans = SP.to_spans ~inalloc ~outalloc ~ra:saved_ra
                          ~users:props ~csregs:nvr_temps
                          ~conts:(List.map label unwind_conts)
                          ~sds:sd_locs ~vars:(var_array ()) in
  let succ_assn = if conts.S.returns then in'.C.insp in'.C.overflow else R.par [] in
  G.stack_adjust out.C.pre_sp                                        **>
  G.instruction  out.C.shuffle                                       **>
  G.stack_adjust out.C.post_sp                                       **>
  G.call m e
    ~uses:(rsx out.C.regs) ~defs:(rsx in'.C.regs) ~kills:(rsx cc.C.volregs)
    ~altrets:conts.S.areturns ~unwinds_to:conts.S.unwinds
    ~cuts_to:conts.S.cuts ~aborts:conts.S.aborts
    ~reads:alias.S.reads ~writes:alias.S.writes ~spans:(Some spans) ~succ_assn **>
  (if conts.S.returns then
    G.stack_adjust in'.C.pre_sp              (* DOUBTS ABOUT THIS *) **>
    G.instruction  in'.C.shuffle                                     **>
    G.stack_adjust in'.C.post_sp succ
   else
    G.forbidden m succ)
@
\paragraph{Returns}
In the presence of tail calls, [[f]] might call [[g]] with
convention~$A$,
[[g]]~might tail-call [[h]] with convention~$B$, and [[h]]~would need
to return to~[[f]] with convention~$A$.
Therefore, it is not only sensible but necessary to annotate the
[[return]] with its own convention.
<<supporting functions for translating statements>>=
and return cconv i n args g = 
  let cc  = Call.get_cc target cconv in
  let out = actuals cc.C.results.C.out args  in
  <<verbosely announce the registers used by the return>>
  let ra_out = cc.C.ra_on_exit saved_ra out.C.overflow temps in
  let w      = Rtlutil.Width.loc saved_ra in
  let upd_ra = if i > 0 then RU.store saved_ra (RU.addk w (RU.fetch saved_ra)
                                                          (i * asm#longjmp_size ()))
               else R.null in
  let reti   = cc.C.return i n (RU.fetch ra_out) in
  add oldblocks cc.C.overflow_alloc.C.result_allocator out.C.overflow;
                      (* outgoing jump overflow = incoming *)
  G.instruction  upd_ra                  **>
  G.stack_adjust out.C.pre_sp            **>
  G.instruction  out.C.shuffle           **>
  G.instruction  (RU.store ra_out (RU.fetch saved_ra))  **>
  G.instruction  restore_nvrs            **>
  G.stack_adjust out.C.post_sp           **>
  G.return       ~exit:i reti ~uses:(rsx (RS.union out.C.regs nvregs)) **>
  g
@ The code above is safe only so long as the outgoing area doesn't
overlap with the spill area.
This restriction is unfortunate, as if we could atomically shuffle
nonvolatile registers, outgoing parameters, and the return address
all in one go, we could overlap the two areas---except for spills.
@
<<verbosely announce the registers used by the return>>=
let () =
  if Debug.on "return-regs" then
    let regstring ((s,_,_), i, R.C c) =
      if c = 1 then Printf.sprintf "%c%d" s i else Printf.sprintf "%c%d:%d" s i c in
    let used = List.map regstring (RS.elements out.C.regs) in
    Printf.eprintf "return statement uses regs: %s\n" (String.concat ", " used) in
<<ast2ir.ml>>=
let () = Debug.register "return-regs" "show registers used by return statememt"
@
\paragraph{Cut to}
The overflow block is part of the representation of the continuation
and is placed in the stack elsewhere, but we need to remember any
constraints associated with this block.
<<supporting functions for translating statements>>=
and cut cc k args conts g = 
  let cc       = Call.get_cc target cc in
  let out      = actuals (cc.C.cut_parms.C.out k) args in
  let cut_args = Contn.cut_args target ~contn:k in
  let ()       = add_constraints (Block.constraints out.C.overflow) in
  let conts    = ccontinuations cc conts in
  G.instruction out.C.shuffle **>
  G.cut_to m cut_args ~cuts_to:conts.S.ccuts ~aborts:conts.S.caborts
           ~uses:(rsx out.C.regs) **>
  g
@ A couple of notes:
The constraints from [[out.C.overflow]] have to get to the solver in
order to resolve the addresses used in [[out.C.shuffle]].
Because the overflow block [[out.C.overflow]] is not part of the stack
frame, these constraints could go to the solver independently (and
right away).
But because the names used in each block are unique, it's just as
safe, and perhaps easier, to send these constraints to the solver
along with all the other constraints of this activation.
@
\paragraph{Stack-limit check}

If the stack is exhausted, pass control to the continuation given.
<<supporting functions for translating statements>>=
and limitcheck cconv cookie cont =
  let w  = W.exp vfp in
  let cc = Call.get_cc target cconv in
  let growth = cc.Call.stack_growth in
  let younger = match growth with
  | Memalloc.Down -> Rewrite.Ops.lt w
  | Memalloc.Up -> Rewrite.Ops.gt w in
  let _extremum = unimpf "old end of stack frame" in
  let overflows = younger vfp cookie in
  let ovnode ~ifso ~ifnot = G.cbranch m overflows ~ifso ~ifnot in
  G.limitcheck m ovnode (limitcheck_fails cconv cont) succ
and limitcheck_fails cconv cont succ = match cont with
| None -> G.forbidden m succ
| Some failure ->
    let failflow = { S.caborts = true; S.ccuts = [failure.S.recname] } in
    cut cconv failure.S.reccont [] failflow **>
    contStmt2 failure.S.recname **>
    succ
@

% ------------------------------------------------------------------ 
\subsection{Translating a procedure}
% ------------------------------------------------------------------ 

This section is a big ball of hair.
There are too many constraints about order.
@ 
\paragraph{Broadly useful values}
The procedure calling convention and virtual frame pointer are everywhere.
The temporaries are not everywhere, but it's convenient to have them
here anyway.
<<definition of [[proc]], which translates one procedure>>=
let proc global_map proc =
  let proc_cc  = Call.get_cc target proc.N.cc in
  let vfp      = target.T.vfp in (* virtual frame pointer *)
  let temps    = Talloc.Multiple.for_spaces target.T.spaces in
@ 
We'll remember labels, too.
<<definition of [[proc]], which translates one procedure>>=
  let uidmap =
    let add map l = SM.add l (G.uid ()) map in
    List.fold_left add SM.empty (Elabstmt.codelabels proc.N.code) in
  let uid_of s = 
    try SM.find s uidmap with Not_found -> impossf "unknown code label" in
@ 
\paragraph{Setting up the control-flow graph}
First step is to set up  the control-flow graph.
We use [[exp_of_label]] below, but once symbols are expunged, it
should be simple enough to drop it (reducing the cognitive load on the
reader). 
<<definition of [[proc]], which translates one procedure>>=
  let exp_of_code_label (u,l) = R.codesym ((F.asm env)#local l) pointersize in
  let machine = T.boxmach in
  let m = (), machine, exp_of_code_label in
@ 
\paragraph{Managing mutable state: blocks, constraints, and call site information}
The important state here is [[youngblocks]], [[oldblocks]], and
[[constraints]]. 
<<definition of type [[blocklists]]>>=
type 'a blocklists = { mutable caller : 'a list; mutable callee : 'a list }
<<definition of [[proc]], which translates one procedure>>=
  let youngblocks        = { caller = []; callee = [] } in
  let oldblocks          = { caller = []; callee = [] } in
  let add blocks party b = match party with
  | C.Caller -> blocks.caller <- b :: blocks.caller
  | C.Callee -> blocks.callee <- b :: blocks.callee in
  let constraints         = ref [] in
  let add_constraints  c  = constraints  := c :: !constraints        in
  let ptrcount =
    let _, _, c = target.T.memspace in Cell.to_count c target.T.pointersize in
  let to_mloc exp =
    R.mem (R.aligned target.T.alignment) target.T.memspace ptrcount exp in
@ 
<<definition of [[proc]], which translates one procedure>>=
  let low_end  block = Block.base block in
  let high_end block =
    let base = Block.base block in
    Rtlutil.addk (W.exp base) base (Block.size block) in
  let young_end cc = match cc.C.stack_growth with
  | Memalloc.Down -> low_end
  | Memalloc.Up   -> high_end in
  let old_end cc = match cc.C.stack_growth with
  | Memalloc.Down -> high_end
  | Memalloc.Up   -> low_end in
@   
\paragraph{Setting up the environment and functions that use it (stack
data, continuations, expressions, parameters)}
Here we rebind [[env]] to include local variables, stack data,
continuations, and so on.
We also bind a separate [[contenv]], which maps the name of a
continuation to its information as type [[K.t]] (see
chunk~\subpageref{ast2ir.K.t}). 
The [[stackdata]] function includes the first pass of translation of
continuations. 
<<definition of [[proc]], which translates one procedure>>=
let formals  = convert_parms (fun ((_, k, _, w, _, a) as parm) -> k, parm, a)
                             (fun (i, _, _, w, n, _) -> AT.of_loc (R.var n i w), w) in
let cformals = convert_parms (fun p -> p)
                             (fun v -> AT.of_loc v.FE.loc, RU.Width.loc v.FE.loc) in
let actuals  = convert_parms (fun ((k, _, _, a) as parm) -> k, parm, a)
                             (fun (_, e, w, _) -> e, w) in
let results  = convert_parms (fun p -> p) (fun (l, w) -> AT.of_loc l, w) in
@ 
@ 
We provide a lookup of continuation by name.
If a continuation is used as an rvalue, we get the address of its
representation.  
We also mark the continuation as escaping.
<<definition of [[proc]], which translates one procedure>>=
  <<function [[extend_cont]], for adding flow-graph info to continuations>>
  let contenv =
    let add env (n, k) = Strutil.Map.add n (extend_cont n k) env in
    List.fold_left add Strutil.Map.empty proc.N.continuations in
  let continuation l =
    try Strutil.Map.find l contenv with _ -> impossf "lost cont %s" l in
@ 
\paragraph{Nonvolatile registers, which are affected by incoming parameters}
We place a restriction on calling conventions supported by C--: a
parameter register is never nonvolatile.  
Therefore, for any particular procedure, we get the nonvolatile
registers for \emph{that} procedure by subtracting off those registers
used as parameters.
This choice constrains the set of calling conventions we can express,
but it makes it easy to express, e.g., the ``lightweight'' calling
convention, in which every register not a parameter is nonvolatile.
N.B. for a return or a jump, it is up to the specification of the
calling convention to avoid a conflict between result registers and
nonvolatile registers.

To figure out which registers are nonvolatile, we run the automaton
for the incoming parameters, putting results in~[[in']]. 
Don't overlook it.

For each nonvolatile register, we track the hardware register in
[[reg]] and the temporary location in [[tmp]].
If we ever want to save nonvolatile registers in conventional
locations, we will add two more pieces of information: a block for
the register and a mutable flag that tells whether the register is
spilled to that block.
<<types for nonvolatile registers>>=
type 'a nvr = { reg : 'a; tmp : 'a }   (* for callee-saves info *)
<<definition of [[proc]], which translates one procedure>>=
  let proc_in'  = formals proc_cc.C.call_parms.C.in' proc.N.formals  in
  let nvregs    = RS.diff proc_cc.C.pre_nvregs proc_in'.C.regs in
  let nvr_temps = 
    RS.fold (fun r i -> (r, Some (proc_cc.C.saved_nvr temps r)) :: i) nvregs [] in
  let convert (r,t) = match t with Some t -> {reg = R.reg r; tmp = t}
                                 | None   -> impossf "Some nvr_temp expected" in
  let nvr_info  = List.map convert nvr_temps in
  let save_nvrs =
    R.par (List.map (fun i -> RU.store i.tmp (RU.fetch i.reg)) nvr_info) in
  let restore_nvrs =
    R.par (List.map (fun i -> RU.store i.reg (RU.fetch i.tmp)) nvr_info) in
  let save_ra, saved_ra =
    let ra_in = proc_cc.C.ra_on_entry proc_in'.C.overflow in
    let loc   = proc_cc.C.where_to_save_ra ra_in temps in
    R.store loc ra_in pointersize, loc in
@
For each procedure, we create a span that represents the location of
the point in the stack that marks the
space that must be deallocated by the procedure.
<<definition of [[proc]], which translates one procedure>>=
  let inalloc =
    match proc_cc.C.overflow_alloc.C.parameter_deallocator with
    | C.Callee -> to_mloc (old_end   proc_cc proc_in'.C.overflow)
    | C.Caller -> to_mloc (young_end proc_cc proc_in'.C.overflow) in
@ 
We also generate an array of variable locations.
The current method is totally bogus: I'm only using the variable numbers.
<<definition of [[proc]], which translates one procedure>>=
  let nvars = List.length proc.N.formals + List.length proc.N.locals in
  (* I DON'T KNOW HOW TO GET A VAR'S NAME!!!! SEE ELSEWHERE ALSO *)
  let var_array () = Array.init nvars (fun i -> Some (R.var "" ~index:i 0)) in
@ 
Perhaps we can save some memory allocation if we only convert the stackdata expressions
to locations one time.
<<definition of [[proc]], which translates one procedure>>=
  let sd_locs = List.map to_mloc proc.N.stacklabels in
@
\paragraph{Supporting procedures}
We now have enough information in scope to drop in the definitions of
the translations for flow annotations, statements, and initialization
of continuations.
<<definition of [[proc]], which translates one procedure>>=
  <<function [[continuations]], which translates flow annotations>> in
  <<functions that translate statements, including [[stmts]]>> in
  <<definition of [[insert_init_cont_nodes]]>> in
@ 
\paragraph{Translation of the procedure body}

This is the ``second pass'' of section~\ref{ast2ir.sec:cont-trans}; it
builds most of the flow graph.
The initialization of continuations is delayed to a third pass, so we
create a label node [[initcont]] as a placeholder.
The initialization code is inserted at [[initcont]] after the translation.
WE OUGHT TO BE ABLE TO DO WITHOUT ONE OF THESE LABEL NODES.
<<definition of [[proc]], which translates one procedure>>=
  let bodylbl = genlabel "proc body start" in
  let contlbl = genlabel "initialize continuations" in
  let () = add oldblocks proc_cc.C.overflow_alloc.C.parameter_deallocator
                         proc_in'.C.overflow in
  let stack_adjust =
    if proc.N.basic_block then (fun _ succ -> succ) else G.stack_adjust in
  let g = 
    G.unfocus                         **>
    stack_adjust proc_in'.C.pre_sp    **>
    G.instruction  proc_in'.C.shuffle **>
    stack_adjust proc_in'.C.post_sp   **>
    G.instruction  save_nvrs          **>
    G.instruction  save_ra            **>
    G.label m contlbl                 **>
    G.label m bodylbl                 **>
    stmts proc.N.spans proc.N.code    **>
    G.entry G.empty in 
@ And as promised, the third pass.
We initialize continuations, finish compiling them, and accumulate
their blocks into [[contblocks]].
CAN'T WE HAVE JUST ONE INSERTION POINT?
AND WOULDN'T IT BE NICER JUST TO CONCATENATE BLOCKS DIRECTLY RATHER
THAN MAKE A LIST AND THEN CONCATENATE?
<<definition of [[proc]], which translates one procedure>>=
  let contblocks, g =
    if proc.N.basic_block then
      Block.cathl_list pointersize [], g
    else
      let addblock name k (blocks, g) =
        let g = finish_compiling_continuation k g in
        let blocks =
          if k.K.escapes then Block.cathl (Contn.rep k.K.rep) k.K.base :: blocks
          else blocks in
        blocks, g in
      let blocks, g = Strutil.Map.fold addblock contenv ([], g) in
      Block.cathl_list pointersize blocks, g in
  let g =
    if proc.N.basic_block then
      g  (* continuations already initialized in prolog of original proc *)
    else
      insert_init_cont_nodes contenv contlbl g in
@ 
\paragraph{the spilling automaton}
The value [[space]] is an infinite supply of registers that stand for
memory locations. We use those registers for spilling. The reason is that
it helps us to build a private block with a better layout by register
allocating those temporaries registers to stack locations.
the alignment of the blxok should probably depend on the alignment of the
stack pointer.
we are going provide several spaces, wich will be chosen depending on the alignment
<<definition of [[proc]], which translates one procedure>>=
  let index = ref 0 in
  let _allocate = fun ~width -> fun ~alignment -> fun ~kind ->
    let () = index := !index + 1 in 
    let spaceId = char_of_int alignment in 
    let cell = Cell.of_size target.Target.wordsize in
    let space = (spaceId, target.Target.byteorder, cell) in  
    AT.of_loc (Rtl.reg (space, !index, Cell.to_count cell width)) 
  and _freeze arg = Impossible.impossible "you must not freeze this automaton" in
 
  (*   
     let index = ref 0 in
     let blocks = ref [] in
     let allocate = fun ~width -> fun ~alignment -> fun ~kind ->
     let () = index := !index + 1 in 
     let spaceId = char_of_int alignment in 
     let cell = Cell.of_size target.Target.wordsize in
     let space = (spaceId, target.Target.byteorder, cell) in
     let block = Block.relative vfp "spills block" Block.at ~size:width ~alignment:alignment in
     let () = blocks := block :: !blocks in
     AT.of_loc (Rtl.reg (space, !index, Cell.to_count cell width))
     and freeze arg1 arg2 = 
     let l = !blocks in
     let () = blocks := [] in
     { AT.overflow = Block.cathl_list target.Target.pointersize l 
     ; AT.regs_used = RS.empty
     ; AT.mems_used = []
     ; AT.align_state = 1   (* oyh oyh oyh  *)
     }
     
     in
   *)
@ 
\paragraph{Building and optimizing the [[Proc.t]]}
We take everything we know and combine it into a [[Proc.t]].
Then function [[optimize]], which is passed in, runs the rest of the
compiler. 
The main thing here is dealing with all the blocks.
<<definition of [[proc]], which translates one procedure>>=
  let formals =
    List.map (fun (i, h, v, w, n, a) -> i, (Some h, v, Ast.BitsTy w, n, Some a))
    proc.N.formals in
  let (i : proc) =    
    g,
    { Proc.symbol      = proc.N.sym
    ; Proc.cc          = proc_cc
    ; Proc.target      = T target
    ; Proc.formals     = formals
    ; Proc.temps       = temps
    ; Proc.mk_symbol   = Fenv.Clean.symbol env
    ; Proc.cfg         = ()
    ; Proc.oldblocks   = (* parms must be first, so call List.rev *)
        { C.callee = List.rev (oldblocks.callee); 
          C.caller = List.rev (oldblocks.caller); }
    ; Proc.youngblocks = (* order doesn't matter *)
        { C.callee = youngblocks.callee; 
          C.caller = youngblocks.caller; }
    ; Proc.stackd         = proc.N.stackmem     (* stack data block *)

    ; Proc.priv           = Block.relative vfp "private"
                            (aligned_mem ~align:proc_cc.C.sp_align) target
(*
    ; Proc.priv           = AT.of_methods {AT.allocate = allocate ; AT.freeze = freeze}
*)
    ; Proc.sp             = Block.at proc_cc.C.stable_sp_loc 0 proc_cc.C.sp_align 
    ; Proc.eqns           = List.concat (!constraints)
    ; Proc.conts          = contblocks
    ; Proc.vars           = nvars              (* number of variables *)
    ; Proc.nvregs         = RS.cardinal nvregs (* number of non-volatile regs *)
    ; Proc.var_map        = Array.make nvars None
    ; Proc.global_map     = global_map
    ; Proc.bodylbl        = bodylbl
    ; Proc.headroom       = !headroom
    ; Proc.exp_of_lbl     = exp_of_code_label
    } in
@ 
Before running the optimizer, we trim away any unreachable code,
as well as spans associated with unreachable code.
<<definition of [[proc]], which translates one procedure>>=
  let i, _ = Optimize.trim_unreachable_code () i in
  optimizer i (* runs optimizer, freezes, and assembles proc *)
@ 
We define an automaton to allocate suitably aligned locations. 
<<utilities>>=
let aligned_mem ~align ~base target = 
  let ( *> ) = AT.( *> ) in
  AT.at target.T.memspace ~start:base (
    AT.align_to (fun w -> min align (w / target.T.memsize)) *>
    AT.overflow ~growth:Memalloc.Up ~max_alignment:align)
@
      
% ------------------------------------------------------------------ 
\subsection{Initialized and uninitialized data}
% ------------------------------------------------------------------ 

Initialized and uninitialized data translate to assembly directives.

A [[datum]] can appear globally inside a section or a section-level
[[span]] and locally inside a procedure as \texttt{stackdata}.  
This code translates global data into assembly actions;
the [[stackdata]] function handles stack data.
<<function [[datum]], for initialized and uninitialized data>>=
let rec datum global_map asm = 
  function
    | N.Datalabel l -> asm#label l  
    | N.Align n     -> asm#align n
    | N.InitializedData es -> List.iter (fun (k, t) -> asm#addr k) es
    | N.UninitializedData n -> asm#zeroes n
    | N.Procedure p -> proc global_map p
@


\subsection{Global Registers}
% ------------------------------------------------------------------ 

A global register either specifies a hardware register, or not. The
hardware register is looked up in the [[named_locs]] table and entered
into the register's symbol-table entry. A register without a hardware
register are pushed trough the [[globals]] automaton and the resulting
location is entered into the register's symbol table entry. 

All compilation units in a program must declare exactly the same global
registers. We compute a cryptographic hash value for all global-register
declarations as a fingerprint. The fingerprint is a string of 16
characters, which may not be printable.

Function [[globals]] returns the enriched environment, the block of
memory that holds overflow global variables, and a fingerprint of the
declarations.
<<definition of [[globals]]>>=
let globals (base:Rtl.exp) vars =
    let t           = target.T.globals base in
    let decls       = Buffer.create 128 in (* initial size - grows as needed *)
    let rec assign bindings (name, var) = match var.FE.rkind with
    | FE.RNone | FE.RKind _ -> 
        (* global register w/o hardware annotation *)
        let w     = RU.Width.loc var.FE.loc in
        let sig'  = Printf.sprintf "[%s %d]" name w in
        let ()    = Buffer.add_string decls sig' in
        let loc   = AT.allocate t w "" 1 in
        (var.FE.index, loc) :: bindings   (* could do even better here *)
    | FE.RReg hw ->
        (* global register with h/w annotation *)
        (try
          let loc   = AT.of_loc (Strutil.Map.find hw target.T.named_locs) in
          let sig'  = Printf.sprintf "[%s %s]" name hw in            
          let ()    = Buffer.add_string decls sig' in
          (var.FE.index, loc) :: bindings
        with Not_found -> impossf "unknown hardware register \"%s\"" hw) in
    let bindings = List.fold_left assign [] vars in
    let gmap =
      let var n = try List.assoc n bindings
                  with Not_found -> impossf "no global register %d" n in
      Array.init (List.length vars) var in
    gmap, AT.freeze t, Digest.string (Buffer.contents decls)    
@
We have to deal somehow with the global-register area, i.e., make it consistent.
The fingerprint [[digest]] for global register declarations is a
16-character string of unprintable characters. We make it printable by 
calling [[idcode]]; using [[String.escaped]] produces identifiers that
are too long for the linker.
<<supporting functions for fooling with the global-register area>>=
let emit_global_register_area ~export =
  let areaname = "Cmm.global_area" in
  let base_sym = if export then asm#export areaname else F.symbol env areaname in
  let base     = Rtl.datasym base_sym pointersize in 
  let gmap, area, digest = globals base prog.N.globals in
  let area     = area.AT.overflow in
  let digest   = "Cmm.globalsig." ^ Idcode.encode digest in
  let asm      = F.asm env in
  let digest   = if export then asm#export digest else asm#import digest in
  (* must move to placevars and use gmap as a replacement map *)
  let _ = 
    if export then 
      begin
        asm#section (target.T.data_section);
        asm#comment "memory for global registers";
        asm#align (Block.alignment area);
        asm#label digest;     (* ensures desired definition is present *)
        asm#label base_sym;   (* ensures no multiple inconsistent definitions *)
        asm#addloc (Block.size area);
        asm#globals (List.length prog.N.globals);
      end
    else
      let localref = asm#local "Cmm.ref_to_global_area" in
      begin
        asm#section (target.T.data_section);
        asm#label localref;
        asm#comment "reference to global-register signature";
        asm#addr (Reloc.of_sym (digest, Rtl.impsym) pointersize);
      end in
  gmap
@
 
% ------------------------------------------------------------------ 
\subsection{Translating a full compilation unit}
% ------------------------------------------------------------------ 

To translate a program, we work our ghastly magic on the
global-register overflow area, then emit all the sections.

THE TREATMENT OF THE GLOBAL-REGISTER AREA IS NOT YET CORRECT.
\begin{itemize}
\item
    The memory block for global registers should go into one compilation
    unit and be imported by all others.  OR PERHAPS IT SHOULD BE
    SUPPLIED AT RUN TIME BY THE FRONT END?
 Currently we just emit it
    because we are far from linking several {\PAL} compilation units.
\item
We don't correctly manage the fingerprint of the global-register
declarations.
\end{itemize}
<<function [[program]], which translates an entire program>>=
let program prog =
  let prog = N.rewrite target.T.tx_ast prog in
  <<supporting functions for fooling with the global-register area>> in
  let global_map = emit_global_register_area defineglobals in
  if defineglobals then
    Runtimedata.emit_global_properties target asm;
  let section asm (name, data) =
    asm#section name; List.iter (datum global_map asm) data in
  List.iter (section asm) prog.N.sections
@
