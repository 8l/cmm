% -*- mode: Noweb; noweb-code-mode: caml-mode -*-

% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Please add grades for this module below. The line must start with % "%%".
% 

%%Grades: B Peripheral Later


% ------------------------------------------------------------------ 
\section{Name Generator}
% ------------------------------------------------------------------ 

For labels, temporary variables, and similar objects generated by the
compiler we need an infinite supply of unique names.  In order to
avoid collisions with existing names in a {\PAL} program these names
are constructed in way that is not availabe at the {\PAL} source
level.  For example, no legal {\PAL} name contains a space and thus
generated names may contain spaces to avoid clases with exitisting
names.  This module provides a generator for names:  every invocation
generates a new name.  To aid debugging, a string can be supplied that
becomes part of the generated name.

The names generated by this module generally \emph{do not} respect the
syntax for symbols of an assembly language.  Names that are used for
assembly symbols are mangled to ensure they conform to the assembler
at hand.  This happens usually in a compiler phase later than the one
where names are introduced.  See module \module{mangle} for the
connection between {\PAL} and assembly names.

% ------------------------------------------------------------------ 
\subsection{Interface}
% ------------------------------------------------------------------ 

The interface provides functions to generate unique names derived from
an existing legal {\PAL} name.  A generator permit to supply a string
that becomes part of the generated name.  The supplied name \emph{must}
be a legal {\PAL} name or the empty string, otherwise it is an unchecked
runtime-error.  Supplying the same name twice will result in different
generated names:  every invocation yields a unique name.

Although one naming scheme could be used for different kinds of names
the interface provides functions for different kinds of names: labels,
temporaries, stack-offsets, and so on.  The kind of a name is encoded in
the generated string and hopefully can aid debugging. The name of a the
functions indicate their purpose. 

<<idgen.mli>>=
type generator = string -> string
val label:      generator       (* denotes pc value *)
val offset:     generator       (* offset in stack       *)
val exit:       generator       (* label for exit node in procedure *)
val cont:       generator       (* symbol for dynamic continuation value *)
val slot:       generator       (* slot address on stack *)
val block:      generator       (* offset in Lua-generated Block.t address *)

module ContEntry : sig
  val cut    : generator       (* label for cut-to entry point *)
  val unwind : generator       (* label for unwind entry point *)
  val return : generator       (* label for alternate-return entry point *)
end
(* add more as needed *)
@

% ------------------------------------------------------------------ 
\subsection{Implementation}
% ------------------------------------------------------------------ 

The implementation must maintain state in order to generate unique
names. We use a counter to create unique strings. {\PAL} names must
not include a colon ``[[:]]'' character; we include such a character
into the generated names to avoid name clashes with existing names.

<<idgen.ml>>=
type generator = string -> string
let count = Reinit.ref 0
@
Names returned by [[id]] use the supplied name as a prefix, followed
by a unique number. 
For a label, the prefix is chosen to be \texttt{.L}, which magically
causes the GNU assembler, linker and debugger to ignore the symbol.
(Contrary to the documentation, which claims that a bare~\texttt{L} is
the magic prefix.)
<<idgen.ml>>=
let id kind s =
    ( incr count
    ; Printf.sprintf "%s%s:%c%d" (if kind == 'l' then ".L" else "") s kind !count
    )
@
The kind of a name is encoded by a single letter in the name.
<<idgen.ml>>=
let label   = id 'l' 
let offset  = id 'o'
let exit    = id 'x'
let cont    = id 'c'
let slot    = id 's'
let block   = id 'b'
module ContEntry = struct
  let cut    = id 'C'
  let unwind = id 'U'
  let return = id 'R'
end
(* add more here as needed *)
@

    

