% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% vim: ts=8 sw=4 et: 

% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon
% ------------------------------------------------------------------ 
\section{Code-Expander for the Dummy Target}
% ------------------------------------------------------------------ 

The {\rtl}s generated by the \module{Ast3ir} module violate the machine
invariant that every {\rtl} must be representable as a machine
instruction. A code-expander establishes this invariant by simplifying
{\rtl}s. This module provides a toy code expander for the [[Dummy]]
target. Although it would be possible to write a generic code expander
that works for all targets, we keep things simple and write a
specialized one. The expander is specified as a set of {\burg} rules.

The idea of code expansion is to store intermediate results into
registers.  Registers come in different flavors (c.f.~module
\module{Targets}); we use the following notion: 

\begin{center}
\begin{tabular}{@{\quad}ll}
$r$& an integer hardware register, or an integer temporary\\
$f$& a floating-point hardware register or a floating-point temporary\\
$m$& memory space\\
$k$& non-bool constant\\
$\oplus$& {\rtl} integer {\rtl} operator \\
$\otimes$& {\rtl} floating-point {\rtl} operator \\
\end{tabular}
\end{center}

Or goal is, to re-write all {\rtl}s to the following form:

\begingroup
\def\gets{$\mathrel{:=}$}%
\let\mc\multicolumn

\begin{center}
\begin{tabular}{rcl@{\quad}l}
$r$     & \gets & $k$ & all constants are considered integers\\
$r$     & \gets & $r$ \\
$r$     & \gets & $\oplus(r, \ldots, r)$ \\
$r$     & \gets & $m[t]$ \\
$r$     & \gets & $f$ & conversion \\
\\ 
$f$     & \gets & $f$ \\
$f$     & \gets & $\otimes(f, \ldots, f)$ \\
$f$     & \gets & $m[t]$ \\
$f$     & \gets & $r$ & conversion\\
\\ 
$m[t]$  & \gets & $r$ & an address in an integer\\
$m[t]$  & \gets & $f$ \\
\end{tabular}
\end{center}
\endgroup

\begin{quote}\it
    What to do with boolean expressions? What to do with guarded
    effects? The code generator emits target-specific {\rtl}s for
    branches, jumps, and so on. There is a danger that we try to
    expand those, how do we avoid that?
\end{quote}

Locations are divided into memory, and registers. Registers are further
divided into floating-point and integer registers where a register is
either a hardware register or a temporary. Memory is addressed by
integer registers, {\rtl} operators take either integer or floating
point arguments and return integer or floating point results
respectively. 

The main point of code expansion is to eliminate complex expressions by
keeping their values in registers. The code passed to the expander
already includes some registers from calling conventions that we in
general do not want to replace. For this reason we only distinguish
between integer and floating point registers, but mostly do not enforce
that values are kept in temporaries. In particular, operands can be a
mix of temporaries and hardware registers holding either integers or
floating point values.

% ------------------------------------------------------------------ 
\subsection{Code Expansion with {\burg}}
% ------------------------------------------------------------------ 

A {\burg} specification consists of non-deterministic rules to cover a
tree. Code generated from that specification finds with dynamic
programming at run-time the rules that cover a given tree with minimal
cost. For code expansion the tree to be covered is an {\rtl}. For the
details of how {\burg} works, see the manual of {\small MLBURG} and
Fraser and Hanson: \textit{Engineering a Simple, Efficient Code
Generator Generator}, {\small ACM} Letters on Programming Languages and
Systems 1, 3 (Sep 1992), 213-226.

<<dummyexpander.mlb>>=
%head {: <<utilities>> :}    
<<terminal types>>
%tail {: <<tail>> :}
%%
<<rules>>
@

% ------------------------------------------------------------------ 
\subsection{Utilities for {\burg} actions}
% ------------------------------------------------------------------ 

To keep the semantic actions of {\burg} rules as simple as possible, we
provide some basic functions in the head of the specification and
abbreviate commonly used modules.

<<utilities>>=
module R  = Rtl
module RP = Rtl.Private
module RU = Rtlutil
module S  = Space
module T  = Target
module C  = Camlburg
module D  = Rtl.Dn      (* Convert Down to private repr. *)
module U  = Rtl.Up       (* Convert Up    to abstract repr. *)
module W  = Rtlutil.Width 
module G  = Cfg4             (* for expanding all RTLs in a CFG *)
module GU = Cfgutil
@

Instead of the always useful [[assert false]] we raise a more
descriptive error. These errors are still considered to be fatal.

<<utilities>>=
exception Error of string
let error msg = raise (Error msg)
@

Most semantic actions transform an expression into a sequence of {\rtl}s
that evaluates the expression into a register and return that register.
Thus, two things are returned: the register where the expression's value
can be found, and the sequence of {\rtl}s. To avoid decomposing returned
pairs, these semantic actions are implemented as a state monad: the
state is the list of accumulated {\rtl}s and a source for temporaries. A
monadic action takes the state, and produces a pair of a new result and
a new state:

<<utilities>>=
type state = R.rtl list * Talloc.Multiple.t
type 'a m  = state -> ('a * state)
@

In particular, we save an {\rtl} in the state with [[exec]]. {\rtl}s are
saved in \emph{reverse exceution order}.

<<utilities>>=
let exec  rtl  = fun (rtls,tmp) -> ((), (rtl :: rtls,tmp)) 
@

The power of monads come from higher-order functions to deal with them.
Here are the standard functions, often called \emph{unit} and
\emph{bind}:

<<utilities>>=
let return a  = fun s -> (a, s)
let (>>=) (m: 'a m) (f: 'a -> 'b m) = fun s -> let (a,s) = m s in f a s 
@

We need a source for new temporaries; the functions [[itmp]] and
[[ftmp]] return a new temporary when applied to the desired width of the
new temporary.

<<utilities>>=
let dtmp = function
    | 2 -> fun(rtls, tmp as state) -> (R.reg ('d', 1, 2), state)
    | w  -> Impossible.impossible 
                (Printf.sprintf "unsupported width for d-space register: %d" w)

let itmp = function
    | 32 -> fun (rtls,tmp as state) -> (Talloc.Multiple.loc tmp 't' 32, state)
    (*
    | 8  -> fun (rtls,tmp as state) -> (Talloc.Multiple.loc tmp 'v'  8, state)
    *)
    | 8  -> fun (rtls,tmp as state) -> (Talloc.Multiple.loc tmp 't'  32, state)
    | w  -> Impossible.impossible 
                (Printf.sprintf "unsupported width for int register: %d" w)
let ftmp = function
    | 64 -> fun (rtls,tmp as state) -> (Talloc.Multiple.loc tmp 'u' 32, state)
    | 32 -> fun (rtls,tmp as state) -> (Talloc.Multiple.loc tmp 'u' 32, state)
    | 8  -> fun (rtls,tmp as state) -> (Talloc.Multiple.loc tmp 'u' 32, state)
    | w  -> Impossible.impossible 
                (Printf.sprintf "unsupported width for float register: %d" w)
@

{\rtl} operators do not distinguish between floating point and integer
values, but we assume the [[Dummy]] machine does. As an oversimplified
experiment, we declare the following operators to be floating point
operators, taking and yielding floating point values.

<<utilities>>=
module StringSet = Set.Make(struct type t = string let compare = compare end)
@

To simplify guarded effects we have to know which operators return
boolean values. All operators that take \emph{and} return boolean values
have been re-written into control-flow structures and do not show up
here. The operators listed here all take non-boolean arguments.

<<utilities>>=
let bool_ops2 = (* boolean valued primitive with non-boolean args *)
    List.fold_right StringSet.add
        ["eq"; "ge"; "geu"; "gt"; "gtu"; "le"; "leu"; "lt"; "ltu"; "ne"]
         StringSet.empty

let is_bool_op2  op     = StringSet.mem op bool_ops2
let is_bool_op1  op     = op = "bool"
@

To create a fetch from a location we have to know the size of the
location. The [[fetch]] function makes this easy.

<<utilities>>=
let fetch t = R.fetch t (W.loc t)
@

% ------------------------------------------------------------------ 
\section{Code Expansion Rules}
% ------------------------------------------------------------------ 

A Variable in a rule pattern matches either an Objective Caml value, or
polymorphic {\burg} value. The Objective Caml values are called terminal
values and recognized by their terminal type. The following types are
terminal:

<<terminal types>>=
%term k width opr exps agg ass index bool bits link late x
@

Note, that in a {\burg} pattern a variable $v$ is an abbreviation for
$v:v$, i.e.~variable $v$ of type $v$. A variable [[width]] is thus
of type [[width]] and thus represents a terminal value.

{\rtl}s are mainly composed of expressions, locations and effects. The
code expander keeps the latter two and replaces an expression by a location
that hold the expression's value. 

The following table summarizes the nonterminals in the rules and their
purpose. 

\begin{tabular}{ll}
    Nonterminal & Meaning \\ 
    \hline
    [[ireg]]        & integer value (in register)\\
    [[freg]]        & floating-point value (in register)\\
    [[creg]]        & value of control register\\
    [[dreg]]        & value of 2 bit control register for FP comparison \\
    [[mem]]         & memory location\\
    [[icell]]       & integer register location\\
    [[fcell]]       & floating-point register location\\
    [[ccell]]       & control register location\\
    [[dcell]]       & 2 bit register for FP comparison result\\
    [[const]]       & constant value\\
    [[addr]]        & memory address\\
    [[stmt]]        & side effect (like assignment)\\
\end{tabular}

The costs associated with burg rules usually reflect the number of
generated {\rtl}s. In addition, we want to penalize the conversion
between integer and floating point registers. A missing cost annotation
defaults to zero.

<<rules>>=
const:      Const(k)
            {: return (U.exp (RP.Const(k))) :}

-- r := k   
ireg:       const [1]
            {:  const                                >>= fun k ->
                itmp (W.exp k)                       >>= fun t  ->
                exec (R.store t k (W.exp k))         >>= fun () ->
                return t
            :}

-- r := $m[addr]            
ireg:       Fetch(mem,width) [1]
            {:  mem           >>= fun m ->
                itmp width    >>= fun t -> 
                exec (R.store t (R.fetch m width) width) >>= fun () ->
                return t
            :}  
            
-- f := $m[addr]
freg:       Fetch(mem,width) [1]
            {:  mem           >>= fun m ->
                ftmp width    >>= fun u -> 
                exec (R.store u (R.fetch m width) width) >>= fun () ->
                return u
            :}
@

Fetches from registers must not to be rewritten, but the fetch
instruction disappears. It is inserted when the value is used in
a right-hand-side context.

<<rules>>=
ireg:       Fetch(icell,width) {: icell :}
freg:       Fetch(fcell,width) {: fcell :}    
dreg:       Fetch(dcell,width) {: dcell :} 
@

Each primitive is matched by one rule. The rule expresses the number of
argument registers and their ``types''. The code below allows to keep
the semantic action for each rule essential. The first argument is a
generator for a temporary for the result. Passing [[itmp]] means, that
the result will be stored in an integer temporary.

<<utilities>>=
let bits2 n = R.bits (Bits.U.of_int n 2) 2

let app0 tmp s x =
    let opr   = R.opr s x in
    let exp   = R.app opr [] in
    let width = W.exp exp in
    tmp width >>= fun t -> 
    (*
    exec (R.store t exp width) >>= fun () ->
    *)
    return t

let app1 tmp s x arg1 =
    arg1 >>= fun a1 ->
    let opr   = R.opr s x in
    let exp   = R.app opr [fetch a1] in
    let width = W.exp exp in
    tmp width >>= fun t ->
    exec (R.store t exp width) >>= fun () ->
    return t

let app2 tmp s x arg1 arg2 =
    arg1 >>= fun a1 -> arg2 >>= fun a2 ->
    let opr   = R.opr s x in
    let exp   = R.app opr [fetch a1; fetch a2] in
    let width = W.exp exp in
    tmp width >>= fun t ->
    exec (R.store t exp width) >>= fun () ->
    return t

let app3 tmp s x arg1 arg2 arg3 =
    arg1 >>= fun a1 -> arg2 >>= fun a2 -> arg3 >>= fun a3 ->
    let opr   = R.opr s x in
    let exp   = R.app opr [fetch a1; fetch a2; fetch a3] in
    let width = W.exp exp in
    tmp width >>= fun t ->
    exec (R.store t exp width) >>= fun () ->
    return t
@


<<rules>>=
dreg:   App0("float_eq", x)               {: app0 dtmp "float_eq" x :}
dreg:   App0("float_gt", x)               {: app0 dtmp "float_gt" x :}
dreg:   App0("float_lt", x)               {: app0 dtmp "float_lt" x :}
dreg:   App0("unordered", x)              {: app0 dtmp "unordered" x :}

const:  App0("round_down", x)             {: return (bits2 3) :}  
const:  App0("round_nearest", x)          {: return (bits2 1) :}
const:  App0("round_up", x)               {: return (bits2 2) :}
const:  App0("round_zero", x)             {: return (bits2 0) :}


ireg:   App1("com",  x, r1:ireg)          {: app1 itmp "com"  x r1 :}
ireg:   App1("lobits",x,r1:ireg)          {: app1 itmp "lobits" x r1 :}
ireg:   App1("neg",  x, r1:ireg)          {: app1 itmp "neg"  x r1 :}
ireg:   App1("sx",   x, r1:ireg)          {: app1 itmp "sx"   x r1 :}
ireg:   App1("zx",   x, r1:ireg)          {: app1 itmp "zx"   x r1 :}

<<rules>>=
ireg:   App2("add",  x, r1:ireg, r2:ireg) {: app2 itmp "add"  x r1 r2 :}
ireg:   App2("and",  x, r1:ireg, r2:ireg) {: app2 itmp "and"  x r1 r2 :}
ireg:   App2("div",  x, r1:ireg, r2:ireg) {: app2 itmp "div"  x r1 r2 :}
ireg:   App2("divu", x, r1:ireg, r2:ireg) {: app2 itmp "divu" x r1 r2 :}
ireg:   App2("mod",  x, r1:ireg, r2:ireg) {: app2 itmp "mod"  x r1 r2 :}
ireg:   App2("modu", x, r1:ireg, r2:ireg) {: app2 itmp "modu" x r1 r2 :}
ireg:   App2("mul",  x, r1:ireg, r2:ireg) {: app2 itmp "mul"  x r1 r2 :}
ireg:   App2("or",   x, r1:ireg, r2:ireg) {: app2 itmp "or"   x r1 r2 :}
ireg:   App2("quot", x, r1:ireg, r2:ireg) {: app2 itmp "quot" x r1 r2 :}
ireg:   App2("rem",  x, r1:ireg, r2:ireg) {: app2 itmp "rem"  x r1 r2 :}
ireg:   App2("rotl", x, r1:ireg, r2:ireg) {: app2 itmp "rotl" x r1 r2 :}
ireg:   App2("rotr", x, r1:ireg, r2:ireg) {: app2 itmp "rotr" x r1 r2 :}
ireg:   App2("shl",  x, r1:ireg, r2:ireg) {: app2 itmp "shl"  x r1 r2 :}
ireg:   App2("shra", x, r1:ireg, r2:ireg) {: app2 itmp "shra" x r1 r2 :}
ireg:   App2("shrl", x, r1:ireg, r2:ireg) {: app2 itmp "shrl" x r1 r2 :}
ireg:   App2("sub",  x, r1:ireg, r2:ireg) {: app2 itmp "sub"  x r1 r2 :}
ireg:   App2("xor",  x, r1:ireg, r2:ireg) {: app2 itmp "xor"  x r1 r2 :}

freg:   App1("fneg", x, r1:freg)          {: app1 ftmp "fneg" x r1 :}

freg:   App2("f2i",  x, r1:freg, r2:dreg) {: app2 itmp "f2i"  x r1 r2 :}
freg:   App2("i2f",  x, r1:ireg, r2:dreg) {: app2 ftmp "i2f"  x r1 r2 :}
freg:   App2("f2f",  x, r1:freg, r2:dreg) {: app2 ftmp "f2f"  x r1 r2 :}

-- FP operations use a rounding mode
freg:   App3("fadd", x, r1:freg, r2:freg, c:dreg) {:app3 ftmp "fsub" x r1 r2 c:}
freg:   App3("fsub", x, r1:freg, r2:freg, c:dreg) {:app3 ftmp "fadd" x r1 r2 c:}
freg:   App3("fdiv", x, r1:freg, r2:freg, c:dreg) {:app3 ftmp "fdiv" x r1 r2 c:}
freg:   App3("fmul", x, r1:freg, r2:freg, c:dreg) {:app3 ftmp "fmul" x r1 r2 c:}

<<rules>>=
--
-- Floating point comparison results are ALWAYS stored in a hardware
-- register. This is a hack.
--

dreg:      App2("fcmp", x, f1:freg, f2:freg) [1]
            {:
                f1 >>= fun f1 -> f2 >>= fun f2 ->
                let o        = R.opr "fcmp" x in
                let exp      = R.app o [fetch f1; fetch f2] in
                let fpcond n = R.reg ('d', n, 2) in
                let r        = fpcond 1 in
                exec (R.store r exp 2) >>= fun () ->
                return r
            :}    
@


A cell is either a register or a memory cell. A register has a constant
address and needs no further re-writing. We just categorize it as
integer, floating-point, or control register. Memory cells include
address expressions which must be rewritten. This is enforced by the
[[addr]] nonterminal, which stands for a register value. Hence, memory
can only be addresses by registers in this model.

<<utilities>>=
let mem sp agg width addr ass=
    addr >>= fun a -> return (R.mem (U.assertion ass) sp agg width a)

let reg sp i width = return (R.reg (sp, i, width))
    

<<rules>>=
addr:       ireg  {: ireg >>= fun r -> return (fetch r) :}

<<rules>>=
mem:        Mem('m', agg, width, addr, ass)  {: mem 'm' agg width addr ass :}
@

The name [[icell]] is poorly chosen. We originally had no syntax for
registers in {\rtl}s, only for cells. 

<<rules>>=
icell:      Reg('r', index, width) {: reg 'r' index width :} 
icell:      Reg('t', index, width) {: reg 't' index width :} 
icell:      Reg('g', index, width) {: reg 'g' index width :} 
icell:      Reg('v', index, width) {: reg 'v' index width :} 
fcell:      Reg('f', index, width) {: reg 'f' index width :} 
fcell:      Reg('u', index, width) {: reg 'u' index width :} 
dcell:      Reg('d', index, width) {: reg 'd' index width :} 
ccell:      Reg('c', index, width) {: reg 'c' index width :} 

error:      Reg(x:char, index, width)
            {: error (Printf.sprintf "register in space '%c'" x) :}

error:      Mem(x:char, agg, width, addr, ass) [10]
            {: error (Printf.sprintf "cell in space '%c'" x) :}    
@

To make sure we can cover every {\rtl}, we allow to move integer
registers into floating-point temporaries, and floating-point registers
into integer temporaries.  We do not like these conversions so we
penalize them with high costs. 

<<rules>>=
-- t := f
ireg:       freg [10]    
            {:  
                freg                                >>= fun u  ->
                let w = W.loc u in 
                itmp w                              >>= fun t  ->
                exec (R.store t (R.fetch u w) w)    >>= fun () ->
                return t
            :} 

-- f := t            
freg:       ireg [10]    
            {:  
                ireg                                >>= fun t ->
                let w = W.loc t in
                ftmp w                              >>= fun u  ->
                exec (R.store u (R.fetch t w) w)    >>= fun () ->
                return u
            :} 
@

{\rtl} effects are covered by the [[stmt]] nonterminal. We allow only
very simple assignments between registers of the same class and
registers and memory. In particular, constants cannot be written to
memory, and no memory-memory transfer is allowed. 

<<utilities>>=
let store left right width =
    left >>= fun l -> right >>= fun r -> 
    return (R.store l (R.fetch r width) width)

let store' left right width =   (* right is a value, not a location *)
    left >>= fun l -> right >>= fun r -> 
    return (R.store l r width)

<<rules>>=
stmt:       Store(mem,   ireg, width)       {: store mem   ireg  width :}
stmt:       Store(mem,   freg, width)       {: store mem   freg  width :}
stmt:       Store(icell, ireg, width)       {: store icell ireg  width :}
stmt:       Store(fcell, freg, width)       {: store fcell freg  width :}
stmt:       Store(ccell, ireg, width) [1]   {: store ccell ireg  width :}
stmt:       Store(dcell, dreg, width)       {: store dcell dreg  width :}
stmt:       Store(dcell, const, width)      {: store' dcell const width :}
stmt:       Store(ccell, const,width)       {: store' ccell const width :}
@

Currently the front end generates guarded expression only for
if-statements. The expression is already simplified such that it is
either [[true]], [[false]], or an application with a boolean result that
takes \emph{non-boolean} arguments. 

I don't know how to handle guarded statements. The guard expression is a
boolean expression. For the moment I treat the guard as a literal and do
not expand it.

<<rules>>=
guard:      True()  {: return (R.bool true)  :}
guard:      False() {: return (R.bool false) :}

guard:      App2(o:string, x, r1:ireg, r2:ireg) 
            [{: if is_bool_op2 o then 0 else C.inf_cost  :}]
            {:  
                r1 >>= fun r1 -> r2 >>= fun r2 ->
                let opr = R.opr o x in
                return (R.app opr [fetch r1; fetch r2])
            :}    

-- we need an extra rule for floating point results that always
-- stay in 'd' space.

guard:      App2(o:string, x, r1:dreg, r2:dreg) 
            [{: if is_bool_op2 o then 0 else C.inf_cost  :}]
            {:  
                r1 >>= fun r1 -> r2 >>= fun r2 ->
                let opr = R.opr o x in
                return (R.app opr [fetch r1; fetch r2])
            :}    

guard:      App1(o:string, x, r1:ireg)
            [{: if is_bool_op1 o then 0 else C.inf_cost  :}]
            {:  
                r1 >>= fun r1 -> 
                let opr = R.opr o x in
                return (R.app opr [fetch r1])
            :}    
           
gstmt:      GStmt(guard,stmt)
            {: 
                guard >>= fun g ->
                stmt  >>= fun s -> 
                return (R.guard g s) 
            :}

gstmts:     Nil() {:  return [] :}
gstmts:     Cons(gstmt,gstmts)
            {: gstmt  >>= fun s  -> gstmts >>= fun ss -> return (s::ss) :}
@

An {\rtl} is a list of guarded statements. 

<<rules>>=
rtl:        Rtl(gstmts) [1]
            {:
                gstmts            >>= fun rtls ->
                exec (R.par rtls) >>= fun ()  ->
                return ()
            :}
@

Here are the cases we cannot handle (yet). 

<<rules>>=
error:      Kill()  {: error "cannot handle Kill" :}
error:      Var()   {: error "Var constructor" :}
error:      Slice() {: error "Slice constrictor" :}
@

% ------------------------------------------------------------------ 
\subsection{Interfacing {\rtl}s with the Expander}
% ------------------------------------------------------------------ 

The code generated from {\burg} rules knows nothing about {\rtl}s. In
order to expand an {\rtl}, we have to traverse it and pass the different
parts to the generated functions whose names we know from the {\small
MLBURG} manual. This code follows here. 

<<tail>>=
let rec map f = function
    | []                        -> conNil ()
    | x::xs                     -> conCons (f x) (map f xs)
@    
  
Make sure that the above function [[map]] is \emph{not} in the same
[[letrec]] as the functions below. In that case it becomes monomorphic
and the code below will not type check! This mistake has taken me some
time to spot.

<<tail>>=  
let rec exp = function
    | RP.Const(RP.Bool(true))   -> conTrue()
    | RP.Const(RP.Bool(false))  -> conFalse()
    | RP.Const(k)               -> conConst(k)
    | RP.Fetch(l,w)             -> conFetch (loc l) w
    | RP.App((o,x),[])          -> conApp0 o x
    | RP.App((o,x),[e1])        -> conApp1 o x (exp e1)
    | RP.App((o,x),[e1;e2])     -> conApp2 o x (exp e1) (exp e2)
    | RP.App((o,x),[e1;e2;e3])  -> conApp3 o x (exp e1) (exp e2) (exp e3)
    | _                         -> error "application with too many args"

and loc = function
    | RP.Mem(char, aff, w, e, ass) -> conMem char aff w (exp e) ass 
    | RP.Reg(sp, i, w)          -> conReg sp i w
    | RP.Var(s, i, w)           -> conVar ()
    | RP.Slice(w,i,loc)         -> conSlice ()
    
and stmt = function
    | RP.Store(l,e,w)           -> conStore (loc l) (exp e) w
    | RP.Kill(loc)              -> conKill ()

and guarded (e,eff)             =  conGStmt (exp e) (stmt eff)

and rtl = function
    | RP.Rtl(gs)                -> conRtl (map guarded gs)
@

The [[rtl]] function returns (the best) plan to rewrite a given {\rtl}.
When this plan is executed, it returns a monadic value that includes the
desired expanded {\rtl}s.

<<tail>>=
let expand tmps (r: R.rtl) = 
    let plan = rtl (D.rtl r) in
    try
        match plan.rtl.Camlburg.action () ([],tmps) with
            | (), (rtls,_) -> rtls
    with 
        Camlburg.Uncovered -> 
            ( List.iter prerr_endline
                [ "cannot expand this RTL:"
                ; RU.ToUnreadableString.rtl r
                ]
            ; assert false
            )
@                        

% ------------------------------------------------------------------ 
\subsection{Expanding an entire {\cfg}}
% ------------------------------------------------------------------ 

{\rtl}s do not live in isolation but belong to a procedure's {\cfg}.
Since procedures are the basic units of compilation we want to expand
all the {\rtl}s of a procedure. This requires to re-write the {\cfg}.

Re-writing the {\cfg} mutates its structure and therefore we have to
obtain first all the nodes whose {\rtl}s we want to expand. We cannot
use the iterator provided by the {\cfg} module because it does not work
under mutation.

[[Cfg]] expands all {\rtl}s of a procedure and returns [[true]], if the 
structure of the procedure's {\cfg} had to be modified.

<<tail>>=
let cfg proc =
    let nodes       = GU.fold_bwd proc.Proc.cfg (fun n ns -> n::ns) []
    and tmps        = proc.Proc.temps   (* source for temporaries *)
    and insert n i  = G.gm_insert_assign_before i n
    and modified    = ref false in
    let expnd node =
        match expand tmps (G.instr node) with
        | last :: preds ->
            ( ignore (List.fold_left insert node preds)
            ; G.upd_instr node (fun _ -> last)
            ; modified := (preds <> [])
            )
        | [] -> assert false 
    in    
        ( List.iter expnd nodes
        ; !modified
        )
@

% ------------------------------------------------------------------ 
\subsection{Exporting the Expander to Lua}
% ------------------------------------------------------------------ 

Code expansion is part of {\qcc}'s backend that is controlled by a Lua
interpreter. To make the expander accessible for Lua code, it is
exported as a Lua primitive [[Expander.dummy]].
<<tail>>=
module Make (ProcT: Lua.Lib.TYPEVIEW with type 'a t = Proc.t): 
    Lua.Lib.USERCODE with type 'a userdata' = 'a ProcT.combined =
struct
    type 'a userdata' = 'a ProcT.combined
    module M (C : Lua.Lib.CORE with type 'a V.userdata' = 'a userdata') =
    struct
      module V  = C.V

      let ( **-> ) = V.( **-> )
      let proc     = ProcT.makemap V.userdata V.projection
      let init =
        C.register_module "Expander" 
        [ "dummy", V.efunc (V.value **-> proc **-> V.result V.bool) (fun _ -> cfg)
        ] 
	(* FIX -- want proper stage *)
    end (*M*)    
end (*Make*)            
@

