% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% vim: ts=8 et sts=4 sw=4
% Grades     ::=    "%%Grades:" Quality Importance Urgency
% Quality    ::=    A|B|C|D|E
% Importance ::=    Central|Subsystem|Peripheral
% Urgency    ::=    Immediate|Soon|Later
%
% Example (at beginning of line): %%Grades: B Central Soon

\iffalse
Clients:

Driver: check produces env, compile consumes it
  
  check: Dirty.empty, Dirty.push, Dirty.emptyscope, Dirty.errorFlag Fenv.clean
  also: consistency check with target

  lualink: Driver.check, Driver.compile need env type (no ops)

\fi

% ------------------------------------------------------------------ 
\section{The Fat Environment}
% ------------------------------------------------------------------ 

The meaning, or denotation, of names in a {\PAL} program are recorded
in an environment.  Because only one environment is used for all
different kinds of names, it is called fat.  The fat environment not
only serves the classic symbol table purpose, but also represents some
global state of the compiler.  It is used to pass around informations
between the different phases of the compiler.  In particular the fat
environment holds informations about:
\begin{itemize}
\item Values, like constants, labels for goto and data, procedures.
\item Types, as they are declared by the [[typedef]] directive.
\item A flag that indicates a serious error.
\end{itemize}

The fat environment comes in two variants:  a \textit{dirty} and a
\textit{clean} one.  A dirty environment is built during the first
phases of compilation:  names bound in a dirty environment can be
either good or bad.  The error propagation combinators from the
\module{error} module are used to deal with good and bad values. 
After the semantics of a {\PAL} program are checked and when no errors
were found a dirty environment is known to bind only good values.  At
this point a clean environment can be generated from the dirty one. 
The clean environment is easier to deal with since it guarantees
statically that all its bound values are good.

% ------------------------------------------------------------------ 
\subsection{Interface: Clean vs.~Dirty}
% ------------------------------------------------------------------ 

A dirty and a clean environment are structurally too different for one
polymorphic implementation of an environment to provide both.  As a
consequence, two modules are provided:  [[Dirty]] and [[Clean]]. 
However, the interfaces of both modules still can be derived from a
single interface [[Env]]:

<<exported signature [[Env]]>>=
module type Env = sig
    type 'a info
    type 'a partial
    val  bad: unit -> 'a info

    <<bindings appearing in signature [[Env]]>>
end
@

By defining [[info]] and [[partial]] appropriately, the interface for
the [[Dirty]] and the [[Clean]] modules can be derived.  The types
[[info]] and [[partial]] describe possibly ``bad'' or unknown values
in the the signature.

\begin{itemize}
\item An [['a info]] is a possibly erroneous value [['a]] in a dirty
      environment, but always an [['a]] in a clean environment.

\item An [['a partial]] is a possibly unavailable value [['a]] in a
      dirty environment, but always an [['a]] value in a clean
      environment.

\item The [[bad]] function creates a erroneous value of the 
      [['a info]] type.  Using this function in a clean environment causes
      is a checked compile-time error.
\end{itemize}      

The two sub-modules [[Dirty]] and [[Clean]] just differ in the meaning
of [[info]] and [[partial]].  A clean environment ensures that all
values are present and that they are good.

<<fenv.mli>>=
<<exposed types shared by clean and dirty environments>>
<<exported signature [[Env]]>>

module Dirty : Env
    with type 'a info    = 'a Error.error
    with type 'a partial = 'a option

module Clean : Env
    with type 'a info    = 'a 
    with type 'a partial = 'a 

val clean : 'proc Dirty.env' -> 'proc Clean.env'
@
The only way to obtain a clean environment is by cleaning a dirty
environment.  However, the dirty environment must not be really dirty: 
All information must be provided and must be ``good''.  Trying
to clean a dirty environment with bad values will result in a checked
run-time error.
@
% ------------------------------------------------------------------ 
\subsection{Getting Started: creating an Environment}
% ------------------------------------------------------------------ 

The [[empty]] function creates an (almost) empty environment and it the
only way to create an environment. For every program the compiler
translates it creates one environment. Upon creation the environment is
passed two important data structures: a [[Srcmap.map]] value and an
assembler [[Asm.assembler]]. A [[Srcmap.map]] value associates a
byte-offset in the input with a more readable triple of file name, line,
and column. An assembler requires symbols to be registered before they
can be used.  Both the source map and the assembler can be observed from
an environment.

IT IS NOT CLEAR TO ME WHY THE TYPE OF THE ASSEMBLER SYMBOL IS ALLOWED
TO LEAK INTO THE FAT ENVIRONMENT. ---NR

BECAUSE THE FAT ENVIRONMENT HOLDS THE ASSOCIATION BETWEEN A NAME AND ITS
SYMBOL. WE ALREADY HAVE PLANS TO TO IMPLEMENT A LOOKUP FUNCTION IN THE
ASSEMBLER AND TO EXPELL THE SYMBOL FROM HERE. --CL
<<bindings appearing in signature [[Env]]>>=
type 'proc env'

(* type env = Proc.t env' *)
type scope
<<types exposed in signature [[Env]]>>
val map : ('b -> 'a) -> 'a env' -> 'b env'

val empty   : Srcmap.map -> Metrics.t -> 'proc Asm.assembler -> 'proc env'
                       (* empty scope stack *)
val srcmap  : 'proc env' -> Srcmap.map
val asm     : 'proc env' -> 'proc Asm.assembler
val metrics : 'proc env' -> Metrics.t
@
% ------------------------------------------------------------------ 
\subsection{Scopes and the Fat Environment}
% ------------------------------------------------------------------ 

The main purpose of the fat environment is to bind values to names. 
In {\PAL} same names have the same meaning everywhere in a program,
and others may differ inside and outside of a procedure.  Example of
the former are [[target]] declarations, and bindings for types and
values for the latter; these bindings are called \emph{scoped}.  This
interface provides a fat environment [[env]], that holds all bindings,
regardless whether they are scoped or un-scoped. 

Bindings for types and values have two scopes: the global scope of the
entire compilation unit, and the scope inside a procedure. So in
principle, the scope changes, when a procedure is entered. However,
{\PAL} has some anomalies with respect to these well known static
scoping rules: 

\begin{itemize}
\item Labels defined inside procedures have global scope: they are
      visible in the entire compilation unit.
\item Values imported inside a procedure have global scope, too.
\end{itemize}

After a procedure is left, only the global bindings are in effect. 
Since a procedure is entered many times in a multi-pass compiler it
pays off to save the bindings for a procedure instead of re-computing
them every time the procedure is entered.  To facilitate this an
[[env]] value is internally divided into two parts:  the first is a
stack of [[scope]]s for values and types, and the second holds all
other \emph{global} information.  The bottom scope in the scope stack
contains all global name and type bindings.  When a procedure is
active all its name and type bindings are in the top-scope.  A
procedure's bindings can be saved by saving the [[top]] scope and
re-used, by [[pop]]'ing it later.
<<bindings appearing in signature [[Env]]>>=
val emptyscope: scope   
val top:        'p env' -> scope            (* top empty = assert false *)
val pop:        'p env' -> 'p env'              (* pop empty = assert false *)
val push:       'p env' -> scope -> 'p env'
@
This sounds more complicated than it is.  Since everything is part of
an [[env]] value, it is the only value that is passed around.  Only
before entering or leaving a procedure the scope stack must be
manipulated.
\begin{itemize}
\item  The scope stack of an [[empty]] [[env]] is also empty. Thus, an
       [[emptyscope]] should be [[push]]'ed first.  An [[env]]
       includes a [[Srcmpa.map]] value, which is required to give
       source code positions (type [[Scrpmap.rgn]] stored in the
       environment a meaning.
\item  Applying [[top]] or [[pop]] to an empty stack scope will result
       in an assertion violation.
\end{itemize}

To inspect the value bindings in a (local) [[scope]], [[foldv]] is
provided:  [[foldv f s z]] applies f to all [[ventry]] values found in
scope [[s]] together with a result value of type [['a]] passed along;
[[z]] is the initial value for the result.
<<bindings appearing in signature [[Env]]>>=
val foldv:      (string -> ventry -> 'a -> 'a) -> scope -> 'a -> 'a
@  

% ------------------------------------------------------------------ 
\subsection{Bindings for Values and Types}
% ------------------------------------------------------------------

Register, label, and procedure declarations are examples for
declarations that bind values to names.  A {\PAL} [[typedef]]
declaration binds types to names.  These declarations are scoped:  a
declaration inside a procedure can shadow a declaration of the same
name at the level of the compilation unit.  The following types
capture the structure of values in {\PAL}.

\begin{itemize}
\item A constant denotes its value directly.
\item A register can be either bound to a hardware register, or it can
      be annotated with a kind. Kinds are used to determine calling
      conventions (see module \module{callconv}). Each register has an
      index that identifies it for the run-time API.
\item Labels come in different flavors:  labels in [[goto]] or inside
      data declarations are plain vanilla.  Procedures are labels in a
      clean environment that include their saved local [[scope]]. 
\end{itemize}

Be careful when dealing with [[goto]] labels and imported values because
of {\PAL}'s idiosyncrasies.  Both have global scope, even when they are
defined inside a procedure.  Consequently, they are added to the
environment (at the outermost/bottom scope) during the first pass, that
enters all globally bound values.  A later pass that enters only locally
visible values must ignore them. 

\emph{The stort below about continuations is wrong. JD would be the best
to straighten it out because he implements continuations. -- CL}

The denotation of a continuation $x$ includes a label $x'$. It is used
during translation the translation of an expressions that refer to $x$:
the reference is first represented as a \emph{symbolic constant}
(c.f.~\module{const}) $x'$ which is later re-written to a pointer into
the run-time stack. This re-write steps needs to distinguish between $x$
and $x'$. 

A continuation is at run-time represented by a pointer to a pair of a
stack-pointer value and a code-pointer. The entry point of the
continuation is represented by a symbol derived from its name. The
pointer to the pair is a symbolic compile-time constant and is
represented by an [[Rtl.late]] value that uses the string part of the
[[denotation]]. A continuation therefore has two values associated with
it: a symbol for its entry point, the other for the pointer to its
run-time representation as a pointer to a pair.  

Some values finally become assembler symbols. When such a value enters
the fat environment we reserve an assembler symbol for it. The symbol
becomes part of the value's denotation.
<<exposed types shared by clean and dirty environments>>=
type regkind       = RReg  of string   (* hardware reg *)
                   | RKind of string   (* calling convention kind *)
                   | RNone             (* none of above *)
@
{\PAL} A register has an [[index]] that identifies it \emph{within its
scope}.  Consequently, global registers are numbered consecutively, and
local registers are numbered consecutively. To avoid confusion with
hardware registers in the compiler backend, we name {\PAL} registers
variables.
<<exposed types shared by clean and dirty environments>>=
type variable =    { index:        int
                   ; rkind:        regkind
                   ; loc:          Rtl.loc
                   ; variance:     Ast.variance
                   }
@
The [[int]] value in the procedure denotation is the number of local
variables, plus the number of parameters. We need this value for the
interpreter.
<<exposed types shared by clean and dirty environments>>=
type symclass      = Proc          of Symbol.t
                   | Code          of Symbol.t    
                   | Data          of Symbol.t
                   | Stack         of Rtl.exp  (* address of slot *)

type denotation    = Constant      of Bits.bits
                   | Label         of symclass
                   | Import        of string * Symbol.t
                                             (* external name, assembly symbol *)
                   | Variable      of variable
                   | Continuation  of continuation
and continuation = { base       : Block.t;   (* always empty; used only for address *)
                     convention : string;
                     formals    : (string * variable * aligned) list;
                                                  (* kinded, aligned formals *)
                     mutable escapes     : bool;  (* used as rvalue *)
                     mutable cut_to      : bool;  (* mentioned in annotation *)
                     mutable unwound_to  : bool;  (* mentioned in annotation *)
                     mutable returned_to : convention list;
                        (* list every convention cc such that there exists
                           a call site with convention cc and that call site
                           `also returns to' the continuation *)
                   } (* might need a convention here *)
and convention   = string
and aligned      = int
@
The complete entry [[ventry]] for a value includes not only its
denotation, but also its type [[Types.ty]], and its source code
position as a [[Srcmap.rgn]] value.
<<types exposed in signature [[Env]]>>=
and  ventry        = Srcmap.rgn * (denotation * Types.ty) info
@ 
For error messages, we provide a way of saying what kind of thing a
symbol denotes.
<<fenv.mli>>=
val denotation's_category : denotation -> string
@
Bindings for types, which are also scoped, are much simpler. A
[[tentry]] for a type includes just its source code position and the
type it denotes:
<<types exposed in signature [[Env]]>>=
and  tentry         = Srcmap.rgn * Types.ty info
@
% ------------------------------------------------------------------ 
\subsection{Binding and Finding Names and Values}
% ------------------------------------------------------------------ 

The following functions bind and find names and types in the top of
the scope stack inside an environment.  The scopes inside the
environment are searched from top to bottom and the first binding
found is returned.  The exception [[Error.ErrorExn]] is raised, if no
binding can be found (applies also when the scope stack is empty). 
 
Since it is illegal to re-bind names and values in the same scope, any
attempt to do so is reported as an error to stdout.  Additionally the
existing binding is re-bound to be bad in case the environment was a
Dirty one, and the error flag (see below) is set.

The denotation of some values include optional informations that are
added by later passes, after an initial binding was entered into the
environment.  Since [[bind]] reports any re-binding as an error, a
special function [[rebindv]] is introduced for this purpose. 
[[rebindv]] introduces the new binding in the topmost scope that has a
binding for the name at hand.  So if you want to update a global
binding make sure, that this scope is at the top because otherwise it
may be shadowed by a binding in a local scope and this one would be
replaced.  It is a checked run-time error if no binding to update is
found.

We had trouble with losing environments with rebound entries in module
[[Ast2ir]]. As an experiment, I have made [[rebindv']] an imperative
version of [[rebindv]] that updates an environment by mutation. 
<<bindings appearing in signature [[Env]]>>=
val bindv           : string -> ventry  -> 'p env' -> 'p env'
val rebindv         : string -> ventry  -> 'p env' -> 'p env'
val rebindv'        : string -> ventry  -> 'p env' -> unit  (* mutates *)
val bindt           : string -> tentry  -> 'p env' -> 'p env'
val findv           : string -> 'p env' -> ventry   (* Error.ErrorExn *)
val findt           : string -> 'p env' -> tentry   (* Error.ErrorExn *)
@ \emph{Think of algebraic rules that describe the interaction of bind
and find}.
@
Sometimes is is necessary to know whether a value is bound in a local
scope.  The following predicate is true, if and only if a given name
is bound in the top scope, \emph{and} the top scope is not the bottom
scope at the same time.  It is an assertion failure to supply an
unknown value.
<<bindings appearing in signature [[Env]]>>=
val is_localv       : string -> 'p env' -> bool     (* *)
@

% ------------------------------------------------------------------ 
\subsection{Error Flag}
% ------------------------------------------------------------------ 

The fat environment holds an error flag.  Is is set at the first error
found in the static semantics of a program.  The function
[[flagError]] sets the flag in the returned environment, [[errorFlag]]
returns the flag's value in [[env]].  The [[flagError]] function obeys
to the following law:
\begin{tabular}{l}
    [[flagError (flagError env) = flagError env]]\\
    [[errorFlag (flagError empty) = true]]       \\
    [[errorFlag empty = false]]
\end{tabular}
<<bindings appearing in signature [[Env]]>>=
val flagError       : 'p env' -> 'p env'
val errorFlag       : 'p env' -> bool
@

% ------------------------------------------------------------------ 
\subsection{Imports, Exports, and Assembler Symbols}
% ------------------------------------------------------------------ 

The translation process assigns certain {\PAL} \emph{names} to
assembly-level \emph{symbols}.  The relation between a name and its
assembly symbol is not straight forward, as explained in
section \ref{sect:fenv:mangle}.  In order to build a map from {\PAL} names to
symbols all imports and exports of a {\PAL} program must be registered.
This is done with [[import]] and [[export]].  To provide meaningful
error messages, both function receive the region of the statement at
hand in the source code. 
<<bindings appearing in signature [[Env]]>>=
val import: Srcmap.rgn -> string -> string -> 'p env' -> 'p env' (* import g as f *)
val export: Srcmap.rgn -> string -> string -> 'p env' -> 'p env' (* export f as g *)
@
The [[symbol env n]] function returns the assembly level symbol for a
{\PAL} name [[n]]. If [[n]] is not associated with an imported or
exported symbol, we register a new local symbol in the assembler and
return it. Since every {\PAL} name should have exactly one associated
symbol it is an unchecked error to call [[symbol]] twice with the same
name.
WHY IN THE WORLD IS THIS ERROR UNCHECKED?
<<bindings appearing in signature [[Env]]>>=
val symbol:   'p env' -> string -> Symbol.t
@

% ------------------------------------------------------------------ 
\subsection{The Details of {\PAL} names and Assembler Symbols}
\label{sect:fenv:mangle} 
% ------------------------------------------------------------------ 

A translation of {\PAL} to assembly code must create assembly level
\emph{symbols} for {\PAL} \emph{names} that represent addresses:
\begin{itemize}
\item Procedures
\item Goto-Labels
\item Data-Labels
\item Continuations
\end{itemize} 

Since names for all objects above have global scope, they are unique
for every compilation unit and thus can, in principle, be used for
their assembly-level symbols, which also have a compilation-unit
scope.  A name from outside a compilation unit can be used after it
was imported; likewise can a compilation unit export a name to make it
accessible for others.  Import and export declarations in {\PAL} allow
to re-name an imported or exported object:
\begin{quote}
    [[import]] $a$ as $c$\\
    [[export]] $c$ as $a$
\end{quote}
The {\PAL} name $c$ corresponds to the assembly level symbol $a$.  In
the presence of renaming, a {\PAL} name $x$ need not 
correspond to the same symbol $x$ on the assembly level.  Even worse,
imports and exports using the [[as]] feature have non-local effects:
\begin{quote}
\begin{verbatim}
import print as p;
print () { ... }
\end{verbatim}
\end{quote}

The assembly symbol [[print]] is already used, although [[p]] is used
on the {\PAL} side to refer to it.  Consequently, a {\PAL} procedure
[[print]] can still be defined, but the name [[print]] can no longer
be used as its assembly symbol.  The {\qcc} compiler must manage names
in order to avoid name clashes caused by re-naming.  The main idea is
to find and record a corresponding assembly symbol for every {\PAL}
name.  To make debugging easier, corresponding names on the {\PAL} and
the assembly side should resemble each other as much as possible.

\subsubsection{The Rules}

Before we go into the details how name conflicts are found and
resolved we like to state the rules that {\PAL} names and assembly
symbols must adhere to.  The following rules apply both for {\PAL}
names and assembler symbols inside a compilation units.
\begin{itemize}
\item A name (symbol) is either imported, or defined, but not both. 
      Every name (symbol) is exactly defined once.  An exported name
      (symbol) must be defined.
\item It is illegal to export a name (symbol) that is imported or to
      import a name that is also exported.
\end{itemize}

According to the rules it is legal to import the same symbol under
different names in {\PAL}:
\begin{quote}
\begin{verbatim}
import f as g;
import f as h;
\end{verbatim}
\end{quote}

A naive translation of the following code could lead to assembly code
that violates the second rule. 
\begin{quote}
\begin{verbatim}
import f as g;
export print as f;
print () { ... }
\end{verbatim}
\end{quote}
On the assembly level [[f]] is both imported and exported, because the
corresponding symbol for [[print]] is [[f]]. The {\qcc} compiler must
detect this problem only by looking at the {\PAL} code and reject this
program. 

% ------------------------------------------------------------------ 
\subsubsection{Design}
% ------------------------------------------------------------------ 

This section sketches how assembly symbols are computed for {\PAL}
names and how an implementation fits into the current compiler
architecture.  For the rest of this section we assume that [[import]]
$a$ is a shortcut for [[import]] $a$ [[as]] $a$, and [[export]] $c$ a
shortcut for [[export]] $c$ [[as]] $c$.

An early pass over the abstract syntax is added to the code that
checks the static semantics.  This pass records all [[import]] and
[[export]] declarations of a compilation unit.  More precisely, two
sets and one map are built:
\begin{itemize}
\item
      Set $I$ of assembly symbols imported by a {\PAL}
      compilation unit:  [[import g]] adds [[g]] to $I$, 
      The symbol [[g]] must not be element of set $E$ (see
      below). 
\item
      Set $E$ of assembly symbols exported by a {\PAL}
      compilation unit: [[export f as g]] adds [[g]] to $E$,
      where [[g]] must be not in $I$.
\item
      A map $m$ from {\PAL} names to their corresponding assembly
      level symbols:
      \begin{center}
      \begin{tabular}{ll}
      {\PAL} & added to map $m$ \\ \hline
      [[import f]]      & [[f]] $\mapsto$ [[f]] \\
      [[import g as f]] & [[f]] $\mapsto$ [[g]] \\
      [[export f]]      & [[f]] $\mapsto$ [[f]] \\
      [[export f as g]] & [[f]] $\mapsto$ [[g]] 
      \end{tabular}
      \end{center}
\item
      The following equations relates $I$, $E$, and $m$:
      $\mathit{range}(m) = I \cup E$. 
\end{itemize}      

The sets $I$ and $E$ together contain the symbols which are determined
by the outside of a module and thus can not be used (in general) for
assembly symbols stemming from {\PAL} names.  Recording them in two
sets is necessary to detect symbols on the assembly side that are
imported and exported at the same time.  The map must be used during
translation of names.

To translate a {\PAL} program to assembly language, not only the
symbols for imported or exported objects must be known but for all
{\PAL} objects that have a corresponding symbol.  The following
algorithm extends the map $m$ such that it maps all relevant {\PAL}
names to their symbols.

The algorithm uses a set $M$ that contains all assembly symbols used
by a program.  Initially it contains the union of $I$ and $E$:  $M
\gets I \cup M$.  Next, the algorithm visits all \emph{definitions} of
objects that have a corresponding symbol and matches them against the
left hand side of the following table. After visiting all definitions,
$m$ contains a mapping from {\PAL} names to assembly symbols.

\begin{center}
\def\dom{\mathit{dom}}
\begin{tabularx}{\hsize}{lX}
    Definition of $c$               & Action \\
    \hline
    [[import]] $c$                  & none \\
    [[import]] $x$ [[as]] $c$       & none \\
    label $c$, $c \in\dom(m)$       & none ($c$ is exported) \\
    label $c$, $c \in M$            & invent a new name $a \not\in M$, 
                                      $M \gets M \cup \{a\}$, 
                                      $m \gets m + (c \mapsto a)$\\
    label $c$                       & $m \gets m + (c \mapsto c)$\\
\end{tabularx}
\end{center}

Imports can be skipped because they are already considered in the
initial map $m$.  The same is true for labels that are exported.  In
most cases the name defined by a label can also be used as a symbol. 
Only when the name symbol is already in use a new symbol must be
invented and marked as used in $M$.

% ------------------------------------------------------------------ 
\subsection{Implementation: Large Scale Structure}
% ------------------------------------------------------------------ 

The implementation tries to exploit the commonalities between the
[[Clean]] and [[Dirty]] module by using a functor [[Env]].  The
differences factored out of [[Clean]] and [[Dirty]] are supplied as an
argument [[Arg]] of type [[Arg]].  The main part of the implementation
is thus the generic functor [[Env]] which is described in the
following section.

<<fenv.ml>>=
module E            = Error     (* handy abbreviations *)
module T            = Types
module Asm          = Asm    
@

The [[Arg]] modules captures the diverse aspects of [[Clean]] and
[[Dirty]].  Different [[Arg]] implementations are passed to functor
[[Env]] to create [[Clean]] and [[Dirty]].

<<fenv.ml>>=
module type Arg = sig
    type 'a partial
    type 'a info
    
    val good    : 'a   -> 'a info
    val asgood  : 'a info -> 'a option
    val bad     : unit -> 'a info
end
@
\begin{itemize}
    \item First of all, informations are more vaguely represented in
    [[Dirty]] than in [[Clean]]: a [[partial]] information might be
    absent in [[Dirty]], but not in [[Clean]]. And an information
    [[info]] can be marked as [[bad]] in [[Dirty]], but not in
    [[Clean]]. Functions help to create [[good]] and [[bad]] values. 

    \item The [[update x y f]] function compares a [[partial info]]
    value [[x]] with a plain one [[y]].  In case they differ, [[f]] is
    called.  This is used to implement the update of values in the
    target environment.  The [[Dirty]] module checks the new [[y]]
    value to be consistent with the old value [[x]]. 
    
    \item The default value is used to create an initial target record
    as part of a [[Dirty.empty]] and [[Clean.empty]]. In [[Dirty]]
    nothing is known about a target yet and thus all fields are
    considered as good, but unknown.

    \item The [[asgood]] function provides a way to access [[info]]
    information.  If the information is absent, [[None]] is returned. 
    In a [[Clean.env]] environment [[asgood]] always returns a
    [[Some]] value.
\end{itemize} 

Here are the two modules for the [[Clean]] and [[Dirty]] environment
which are instances of [[Env]], which basically is \emph{the}
implementation of this module.  The arguments to [[Env]] are
implementations of [[Arg]].

<<fenv.ml>>=
<<exposed types shared by clean and dirty environments>>
<<private types shared by clean and dirty environments>>
<<exported signature [[Env]]>>
module Env (Arg: Arg) = struct <<body of functor [[Env]]>> end

<<fenv.ml>>=
module Dirty = Env (struct
    type 'a partial = 'a option
    type 'a info    = 'a Error.error
    
    let good    x   = Error.Ok(x)
    let bad     x   = Error.Error
    let asgood = function
        | Error.Ok(x) -> Some x
        | Error.Error -> None
end)

<<fenv.ml>>=
module Clean = Env (struct
    type 'a partial             = 'a 
    type 'a info                = 'a

    let good x                  = x
    let asgood x                = Some x
    let bad  x                  = assert false
end)
@

% ------------------------------------------------------------------ 
\subsection{The Heart of the Implementation: [[Env]]}
% ------------------------------------------------------------------ 

The fat and the clean version of an environment share the same basic
implementation [[Env]] which is functorized over [[Arg]]. [[Arg]]
provides us what we need to know about good and bad values:

<<body of functor [[Env]]>>=
type 'a partial     = 'a Arg.partial
type 'a info        = 'a Arg.info
let  bad            = Arg.bad
@

Our interfaces includes definitions for types that capture the
denotation of values and types. Of course, these types must be defined
in the implementation as well.

<<body of functor [[Env]]>>=
type 'proc env'    =  { scopes          :    scope list (* top = hd scopes *)
                      ; srcmap          :    Srcmap.map
                      ; asm             :    'proc Asm.assembler
                      ; error           :    bool
                      ; metrics         :    Metrics.t
                      ; extern          :    extern
                      ; globals         :    string  list(* global registers *)
                      ; stackdata       :    stackdata
                      }
<<types exposed in signature [[Env]]>>
<<private types shared by clean and dirty environments>>=
type stackdata =      { soffset    :    int    (* current offset *)
                      ; smaxalign  :    int    (* max stackdata align constr*)
                      ; sname      :    string (* label for offset *)
                      }
@
Imports and exports are recorded (see module \module{mangle}) to build
a map from {\PAL} names to assembly symbols.  The [[extern]] type holds
two sets of assembly symbols:  [[imported]] and [[exported]], and a
map from {\PAL} names to symbols.
<<private types shared by clean and dirty environments>>=
type extern         = { imported:     Strutil.Set.t
                      ; exported:     Strutil.Set.t
                      ; nam2sym:      Symbol.t Strutil.Map.t
                      }
@

A [[scope]] is record of two maps for values and types respectively:

<<body of functor [[Env]]>>=
and scope           = { mutable venv:   ventry Strutil.Map.t
                      ; tenv:   tentry Strutil.Map.t
                      ; rindex: int   (* getIndex, nextIndex *)
                      }
@

An entire environment [[env]] contains the stack of scopes and members
for all non-scoped information, like the target, imports and exports,
error flag, and so on.

% ------------------------------------------------------------------ 
\subsection{Auxiliaries}
% ------------------------------------------------------------------ 

A handy error printing function: [[r]] is a [[Srcmap.reg]] source code
position that is used to describe the place where an error is located. 

<<body of functor [[Env]]>>=
let error r map msg = E.errorRegionPrt (map,r) msg 
@

<<fenv.ml>>=
let denotation's_category = function
  | Label (Proc  _) -> "procedure"
  | Label (Code  _) -> "code label"
  | Label (Data  _) -> "data label"
  | Label (Stack _) -> "stackdata label"
  | Constant _      -> "constant"
  | Continuation _  -> "continuation"
  | Import (_, _)   -> "imported symbol"
  | Variable _      -> "register variable"
@ 
% ------------------------------------------------------------------ 
\subsection{Mapping}
% ------------------------------------------------------------------ 

<<body of functor [[Env]]>>=
let map f { scopes      = scopes     
          ; srcmap      = srcmap     
          ; asm         = asm        
          ; error       = error      
          ; metrics     = metrics     
          ; extern      = extern     
          ; globals     = globals    
          ; stackdata   = stackdata  
          } =
          { scopes      = scopes     
          ; srcmap      = srcmap     
          ; asm         = Asm.map f asm        
          ; error       = error      
          ; metrics     = metrics     
          ; extern      = extern     
          ; globals     = globals    
          ; stackdata   = stackdata  
          }
@ 

% ------------------------------------------------------------------ 
\subsection{Creating \texttt{env} and \texttt{scope} values}
% ------------------------------------------------------------------ 

Given the stack semantics for scopes, the implementation is obvious. 
<<body of functor [[Env]]>>=
let empty map metrics asm =  
    { scopes    = []
    ; srcmap    = map
    ; asm       = asm
    ; error     = false
    ; globals   = []
    ; stackdata = { smaxalign  = 1
                  ; soffset    = 0
                  ; sname      = "can't happen"
                  }
    ; metrics   = metrics
    ; extern    = { imported   = Strutil.Set.empty
                  ; exported   = Strutil.Set.empty
                  ; nam2sym    = Strutil.Map.empty
                  }
    } 
@
The implementation of the [[scope]] stack provides no surprises.
<<body of functor [[Env]]>>=
let emptyscope          = { venv   = Strutil.Map.empty
                          ; tenv   = Strutil.Map.empty 
                          ; rindex = 0
                          }

let srcmap  {srcmap=m}  = m
let asm     {asm=a}     = a 
let metrics {metrics=m} = m 

let top env = match env.scopes with
    | []    -> assert false
    | s::ss -> s

let pop env = match env.scopes with
    | []     -> assert false
    | s::ss  -> { env with scopes = ss }

let push env scope = { env with scopes = scope :: env.scopes } 
@

<<body of functor [[Env]]>>=
let foldv f {venv=v} z = Strutil.Map.fold f v z
@


% ------------------------------------------------------------------ 
\subsection{Binding and Finding Names and Values}
% ------------------------------------------------------------------ 

<<body of functor [[Env]]>>=
type typedefn = (Ast.ty * string list) * Ast.region
let addTypedefn t env = assert false
let typedefns env = assert false
let setTypedefns ts env = assert false
<<body of functor [[Env]]>>=
type constdefn = (Ast.ty option * string * Ast.expr) * Ast.region
let addConstdefn t env = assert false
let constdefns env = assert false
let setConstdefns ts env = assert false
@ 
New Bindings are recorded in the top scope; it is a checked run-time
error if the scope stack is empty.  It is illegal in {\PAL} to re-bind
names:  if the name to be bound is found in the top scope, an error is
issued, the error flag is set, and the existing binding is re-bound to
a bad value.  

Register values that use a hardware register are
additionally recorded in the [[regdecls]] component.
<<body of functor [[Env]]>>=
let bindv name (rgn,x as ventry) env = 
    let scope = ( match env.scopes with
                | []    -> assert false
                | s::ss -> s
                ) in
    try let (rgn',x) = Strutil.Map.find name scope.venv in
        ( error rgn  env.srcmap ("re-declaration of value "^name)
        ; error rgn' env.srcmap ("previously declared here")
        ; let scope = 
            { scope with venv = Strutil.Map.add name (rgn',Arg.bad()) scope.venv} 
          in
            { env with 
              scopes = scope :: List.tl env.scopes  
            ; error  = true  
            }
        )              
    with Not_found -> 
        let scope = { scope with venv = Strutil.Map.add name ventry scope.venv} in
        let env   = { env with scopes = scope :: List.tl env.scopes } in
            ( match Arg.asgood x with
            | Some(Variable _,_) when List.length env.scopes = 1 ->
                  (* this is a global register declaration *)
                  { env with globals = name :: env.globals }
            | _ -> env
            ) 

<<body of functor [[Env]]>>=
let bindt name (rgn,x as tentry) env = 
    let scope = ( match env.scopes with
                | []    -> assert false
                | s::ss -> s
                ) in
    try let (rgn',x) = Strutil.Map.find name scope.tenv in
        ( error rgn  env.srcmap ("re-declaration of type "^name)
        ; error rgn' env.srcmap ("previously declared here")
        ; let scope = 
            { scope with tenv = Strutil.Map.add name (rgn',Arg.bad()) scope.tenv} 
          in
            { env with 
              scopes = scope :: List.tl env.scopes  
            ; error  = true
            }
        )              
    with Not_found -> 
        let scope = { scope with tenv = Strutil.Map.add name tentry scope.tenv} in
        let env   = { env with scopes = scope :: List.tl env.scopes } in
            env
@
The [[find]] functions start searching in the top of the stack and
move to the bottom. The first binding found is returned, and
[[Error.ErrorExn]] raised otherwise.
<<body of functor [[Env]]>>=
let findv name env =
  let rec loop = function
    | []    -> E.error ("unknown value: "^name)
    | s::ss -> (try Strutil.Map.find name s.venv with Not_found -> loop ss) in
  loop env.scopes
<<body of functor [[Env]]>>=
let findt name env =
  let rec loop = function
    | []    -> E.error ("unknown type: "^name)
    | s::ss -> ( try Strutil.Map.find name s.tenv with Not_found -> loop ss ) in
  loop env.scopes
@
The [[rebindv]] function replaces the most local binding for a name. 
<<body of functor [[Env]]>>=
let rebindv name x env =
    let rec loop = function
        | []    -> Impossible.impossible ("can't rebind "^name)
        | s::ss -> if Strutil.Map.mem name s.venv 
                   then { s with venv = Strutil.Map.add name x s.venv } :: ss
                   else s :: loop ss in
    { env with scopes = loop env.scopes }

let rebindv' name x env =
    let rec loop = function
        | []    -> Impossible.impossible ("can't rebind "^name)
        | s::ss -> if Strutil.Map.mem name s.venv 
                   then s.venv <- Strutil.Map.add name x s.venv 
                   else loop ss in
    loop env.scopes 
@
An assertion fails if the scope stack is empty.
<<body of functor [[Env]]>>=
let is_localv name env = 
    ( match env.scopes with
    | []    -> assert false
    | [s]   -> false
    | s::ss -> Strutil.Map.mem name s.venv
    )
@
% ------------------------------------------------------------------ 
\subsection{The Error Flag}
% ------------------------------------------------------------------ 

The fat environment also holds an error flag.  Is is set at the first
error found in the static semantics of a program.  The function
[[flagError env]] sets the flag in the returned environment,
[[errorFlag]] returns the flag's value in [[env]].
<<body of functor [[Env]]>>=
let flagError env = if env.error then env else { env with error = true }
let errorFlag env = env.error
@
% ------------------------------------------------------------------ 
\subsection{Imports, Exports, Symbols}
% ------------------------------------------------------------------ 

The fat environment maintains the set of imported and exported assembly
\emph{symbols} and a map, that associates {\PAL} names with its symbol.
No assembly symbol may be imported and exported at the same time. If
such a case is detected, an error message is issued. Details about the
connection between {\PAL} names and assembly symbols can be found in
\module{mangle}.
<<body of functor [[Env]]>>=
let import r sym name env =
    if Strutil.Set.mem sym env.extern.exported 
    then 
        ( error r env.srcmap ("import of an exported name: "^name)
        ; flagError env
        )
    else 
        let sym'   = env.asm#import sym in
        let extern = { exported = env.extern.exported
                     ; imported = Strutil.Set.add sym  env.extern.imported
                     ; nam2sym  = Strutil.Map.add name sym' env.extern.nam2sym
                     }
         in
            { env with extern = extern }

let export r name sym env =
    if Strutil.Set.mem sym env.extern.imported 
    then 
        ( error r env.srcmap ("export of an imported name: "^name)
        ; flagError env
        )
    else 
        let sym'   = env.asm#export sym in
        let extern = { imported = env.extern.imported
                      ; exported = Strutil.Set.add sym env.extern.exported
                      ; nam2sym  = Strutil.Map.add name sym' env.extern.nam2sym
                      }
         in
            { env with extern = extern }
@
If a name [[n]] is imported or exported, we find its corresponding
assembler symbol in the [[nam2sym]] map. If we can't find it there we
would like to register a new symbol for [[n]]. However, [[n]] might be
have been used already for an exported or imported symbol: 
[[export c as n]] registers a symbol for [[n]] such that any
other entity [[n]] 
cannot register [[n]] for a symbol. We detect this by checking the sets
of names that were registered for imported and exported symbols. In the case
of such a collision we derive a new name from [[n]] that we use to
generate a symbol for [[n]].
<<body of functor [[Env]]>>=
let symbol env n =
    try Strutil.Map.find n env.extern.nam2sym
    with Not_found ->
        let rec avoid_collision n =
            if Strutil.Set.mem n env.extern.exported ||
               Strutil.Set.mem n env.extern.imported
            then
                avoid_collision (n ^ "@")
            else
                n
        in
            env.asm#local (avoid_collision n)
@

% ------------------------------------------------------------------ 
\subsection{Register Index}
% ------------------------------------------------------------------ 

No surprises here. The index is local to the current scope!

<<body of functor [[Env]]>>=
let nextIndex  env   = match env.scopes with
                       | top::t -> { env with scopes = 
                                        {top with rindex = top.rindex + 1}::t
                                   } 
                       | _      -> assert false (* no scope *)

let getIndex   env   = match env.scopes with
                       | top::_ -> top.rindex
                       | _      -> assert false (* no scope *)
                       
@

% ------------------------------------------------------------------ 
\subsubsection{Hardware Registers}
% ------------------------------------------------------------------ 

The list of global register declarations is built in reverse order by
[[bindv]].  So we have to reverse it when we return it.

<<body of functor [[Env]]>>=
let globals env = List.rev env.globals
@

% ------------------------------------------------------------------ 
\subsection{Cleaning a fat environment}
% ------------------------------------------------------------------ 

A [[Clean.env]] is created from a [[Dirty.env]] by copying values from
one to another.  The string typing discipline of {\ocaml} precludes
the use of patterns in most cases such that values must be copied
explicitly.

<<fenv.ml>>=
let clean_env map =
    let copy key data map = match data with
    | pos, E.Ok den -> Strutil.Map.add key (pos, den) map
    | _,   E.Error  -> assert false in
    Strutil.Map.fold copy map Strutil.Map.empty      
@ 
<<fenv.ml>>=
let clean_scope s =
    { Clean.tenv   = clean_env s.Dirty.tenv
    ; Clean.venv   = clean_env s.Dirty.venv
    ; Clean.rindex = s.Dirty.rindex
    }
@ 
<<fenv.ml>>=
let clean env =
    { Clean.scopes    = List.map clean_scope env.Dirty.scopes
    ; Clean.srcmap    = env.Dirty.srcmap 
    ; Clean.asm       = env.Dirty.asm
    ; Clean.error     = env.Dirty.error
    ; Clean.metrics   = env.Dirty.metrics
    ; Clean.stackdata = env.Dirty.stackdata
    ; Clean.globals   = env.Dirty.globals
    ; Clean.extern    = env.Dirty.extern
    }
@
