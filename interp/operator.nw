% -*- mode: Noweb; noweb-code-mode: c-mode -*- %

\ifx\nointro\undefined
This document contains the interface and implementation of {\PAL} primitive operators.
\fi

% ----------------------------------------------------------------------------
\interface{[[operator]] : {\PAL} Primitive Operators}
% ----------------------------------------------------------------------------

<<operator.h>>=
#ifndef _OPERATOR_H
#define _OPERATOR_H

#include "table.h"
#include "stack.h"

<<type definitions>>
<<global variable declarations>>
<<function prototypes>>

#endif /* _OPERATOR_H */
@ 

% ----------------------------------------------------------------------------
\subsection{Global Data Structures}
% ----------------------------------------------------------------------------

The currently-available operators are stored in a global Lua table.
<<global variable declarations>>=
extern table operator_table;
@ 
<<global variable definitions>>=
table operator_table;
@ 
% ----------------------------------------------------------------------------
\subsection{Managing Memory for [[operator]]s}
% ----------------------------------------------------------------------------

To abstract away from the details of memory management, this interface
provides a function to create a new [[operator]] and a function that frees
all existing [[operator]]s in memory.
<<internal function prototypes>>=
static operator *operator_new(void);
<<function prototypes>>=
void      operator_free_all(void);
@ Note that [[operator_new]] returns a pointer to an \emph{uninitialized} 
[[operator]].
@
% ----------------------------------------------------------------------------
\subsection{Generating Operator Definitions}
% ----------------------------------------------------------------------------

Operator definitions are actually generated by a set of macro calls.
[[BINARYOP]], [[UNARYOP]], and [[NULLARYOP]] are macros that generate
binary, unary, and nullary operator function definitions,
respectively.\\ 
\\
\begin{tabularx}{\linewidth}{lXX}\hline
Macro Name & Arguments & Argument Descriptions\\
\hline
BINARYOP & \emph{unquoted string literal} [[NAME]] & function name stem \\
         & \emph{expression}              [[EXP]]  & resulting expression, written in terms of variables [[X]] and [[Y]] \\
         & \emph{variable name}           [[X]]    & the name of the first variable (first argument to operator) \\
         & \emph{variable name}           [[Y]]    & the name of the second variable (second argument to operator) \\
         & \emph{C type}                  [[TX]]   & the C type of variable [[X
]] \\
         & \emph{C type}                  [[TY]]   & the C type of variable [[Y]] \\
         & \emph{C type}                  [[T]]    & the C type of the return value \\
         & \emph{{\PAL} type}             [[BX]]   & the {\PAL} type of variable [[X]] \\
         & \emph{{\PAL} type}             [[BY]]   & the {\PAL} type of variable [[Y]] \\
         & \emph{{\PAL} type}             [[B]]    & the {\PAL} type of the return value \\
\hline
UNARYOP  & \emph{unquoted string literal} [[NAME]] & function name stem \\
         & \emph{expression}              [[EXP]]  & resulting expression, written in terms of variable [[X]] \\
         & \emph{variable name}           [[X]]    & the name of the input variable (argument to operator) \\
         & \emph{C type}                  [[TX]]   & the C type of variable [[X
]] \\
         & \emph{C type}                  [[T]]    & the C type of the return value \\
         & \emph{{\PAL} type}             [[BX]]   & the {\PAL} type of variable [[X]] \\
         & \emph{{\PAL} type}             [[B]]    & the {\PAL} type of the return value \\
\hline
NULLARYOP & \emph{unquoted string literal} [[NAME]] & function name stem \\
          & \emph{expression}              [[STMS]] & a list of syntactically valid C statements that need to be evaluated in the function's body \\
          & \emph{variable name}           [[X]]    & the name of the variable used in [[STMS]] and into which the return value is stored \\
          & \emph{C type}                  [[T]]    & the C type of the return value \\
          & \emph{{\PAL} type}             [[B]]    & the {\PAL} type of the return value \\
\hline
\end{tabularx}

These macros are joined by cousins.
[[IBINARYOP]] is an imperative form of [[BINARYOP]] that has a [[STMS]] argument instead of its [[EXP]] argument.
[[T_BINARYOP]], [[T_UNARYOP]], and [[T_IBINARYOP]] are versions of the above macros that assume all arguments and the return value share the same C type and {\PAL} type (there are no [[TX]], [[TY]], [[BX]], or [[BY]] arguments to these macros).
Below is a sample use of these macros, showing how the operators
[[leu]] (the unsigned $\le$ operator) and [[com]] (the bitwise
negation operator) are defined: 
<<sample macro calls>>=
BINARYOP (leu, v1 <= v2, v1, v2, u_int16, u_int16, bool, bits16, bits16, bool)
T_UNARYOP(com, ~v1,      v1,     u_int16,                bits16              )
@
Additionally, a few other macros help with simplifying the macro calls
to construct operators: [[ROTL(T, B)]] and [[ROTR(T, B)]] generate
binary operator definitions of left and right bitwise rotation,
respectively; and [[POPCNT(T, B)]] generates the unary operator
definition of the [[popcnt]] operator (counts the number of 1-bits in
a value). 
@
% ----------------------------------------------------------------------------
\subsection{Operator Registration}
% ----------------------------------------------------------------------------

Helping to register C function implementations of {\PAL} operators is
helper [[register_operator]]. 
This helper takes the string description of the operator (as it would
be called from {\PAL}), a pointer to the implementing C function, the
number of arguments the operator takes, and the operator's
signature). 

An operator signature is a string indicating the bit-widths of the operator's
arguments and return value: the {\PAL} types of an operator's arguments are
placed in a comma-delimited list (in order), and followed by a colon ([[:]])
and the {\PAL} type of the operator's return value.
For example, an operator that takes a 32-bit value and a 16-bit value as
arguments and returns an 8-bit value would have this signature: 
[["bits32,bits16:bits8"]].
Note that spaces are not allowed in the signature.
<<internal function prototypes>>=
static void register_operator(const char *name,  operator_fun f, 
                              unsigned num_args, const char *sig);
@
To batch register all default-supported operator instantiations, we provide
[[init_operators]].
<<function prototypes>>=
void init_operators(void);
@ 
% ----------------------------------------------------------------------------
\implementation{{\PAL} Primitive Operators}
% ----------------------------------------------------------------------------

<<operator.c>>=
#include "operator.h"

#include <stdlib.h>

#include "util.h"
#include "cmmfloat.h"    /* for rounding mode handling */
#define __USE_ISOC99 1
#include <math.h>
#define notnan(X)  (!cmm_isnan(X))
#define notnanf(X) (!cmm_isnanf(X))

#include "stack.h"
#include "table.h"
#include "types.h"
#include "lualink.h"
#include "interp.h"

#include <cii/atom.h>
#include <cii/arena.h>
#include <cii/mp.h>

static double loophole[2];

#define LOOPHOLE(TYFROM, TYTO, VAL) (AT(loophole, TYFROM) = (VAL), AT(loophole, TYTO))
#define AT(ADDR, TY) (*(TY *)(ADDR))

<<64-bit workarounds>>

<<macro definitions>>
<<macro synonyms>>

<<internal function prototypes>>
<<internal static variable definitions>>

<<operator definitions>>

<<global variable definitions>>
<<function definitions>>
@ 
I hate C, because there's no portable way to do 64-bit arithmetic.
Here I assume the compiler supports [[long long]],
and I do conditional compilation in hopes that long long expressions
are 64~bits.
<<64-bit workarounds>>=
typedef long long ll;
typedef unsigned long long ull;

#define LL64(E) (sizeof(long long) == 64 / 8 ? (E) : (assert(0), 0))
@
Because the interpreter is not configured for 64-bit values on the
stack, I use a macro to turn off operators that take 64-bit arguments
or produce 64-bit results.
But because other operators (overflow, carry, and borrow) use 64-bit
integers internall, we still need the other workarounds above.
<<64-bit workarounds>>=
#define OP64(STUFF)   /* no 64-bit args or results in the interpreter */
@
% ----------------------------------------------------------------------------
\subsection{Data Structures}
% ----------------------------------------------------------------------------

\paragraph{Operator Records}

We represent a {\PAL} operator with a [[typedef]]'d [[struct]]: the
[[operator]] data type.  However, we actually implement the operators
themselves with C functions that take one argument (a value stack) and
return a new value stack. 
<<type definitions>>=
typedef valstack (*operator_fun)(valstack values);

typedef struct {
  const char   *opname;  /* operator name */
  unsigned     num_args;
  operator_fun f;
} operator;
@
We also define a few types for dealing with floating-point operations.
<<type definitions>>=
typedef enum {
  FLOAT_LT  = 00U,
  FLOAT_EQ  = 01U,
  FLOAT_GT  = 02U,
  UNORDERED = 03U
} float_comparison;
@ 
% ----------------------------------------------------------------------------
\subsection{Memory Allocation}
% ----------------------------------------------------------------------------

We use Hanson's ``arenas'' (see \emph{C Interfaces and Implementations})
to help allocate and de-allocate memory for [[operator]]s.
<<internal static variable definitions>>=
static Arena_T operator_arena = NULL;
<<function definitions>>=
static operator *operator_new(void) {
  operator *op;

  if (operator_arena == NULL) {
    operator_arena = Arena_new();
    mem_assert(operator_arena);
  }

  op = (operator *) Arena_alloc(operator_arena, sizeof(operator), 
                                __FILE__, __LINE__);
  mem_assert(op);
  return op;
}

void operator_free_all(void) {
  if (operator_arena != NULL) {
    Arena_free(operator_arena);
    Arena_dispose(&operator_arena);
    operator_arena = NULL;
  }
}
@ 
% ----------------------------------------------------------------------------
\subsection{Operator Definitions}
% ----------------------------------------------------------------------------

Operators are mostly implemented through macro-generated functions and
are instantiated at specific types. 
<<operator definitions>>=
  <<floating-point operator definitions>>
  <<integer operator definitions>>
@ \emph{Be aware that these macro definitions are also used by the
  test infrastructure to generate C~functions that are used in
  automated testing.}
@
To associate operator instantiations with the C functions
that implement them,
we use a Lua table represented in C by global variable [[operator_table]] 
(of type [[table]]).
@
% ----------------------------------------------------------------------------
\subsubsection{Floating-Point Operators}
% ----------------------------------------------------------------------------

We use one macro call per operation to generate the implementations of
the IEEE 594 floating-point operations called for in the {\PAL}
language specification. 
<<floating-point operator definitions>>=
/* FLOAT operators begin here. */
NULLARYOP(float_lt , { v1 = FLOAT_LT ; }, v1, u_int8, bits2)
NULLARYOP(float_eq , { v1 = FLOAT_EQ ; }, v1, u_int8, bits2)
NULLARYOP(float_gt , { v1 = FLOAT_GT ; }, v1, u_int8, bits2)
NULLARYOP(unordered, { v1 = UNORDERED; }, v1, u_int8, bits2)
BINARYOP (feq, v1 == v2, v1,v2, float32, float32, bool, bits32, bits32, bool)
BINARYOP (feq, v1 == v2, v1,v2, float64, float64, bool, bits64, bits64, bool)
BINARYOP (fge, v1 >= v2, v1,v2, float32, float32, bool, bits32, bits32, bool)
BINARYOP (fge, v1 >= v2, v1,v2, float64, float64, bool, bits64, bits64, bool)
BINARYOP (fgt, v1 >  v2, v1,v2, float32, float32, bool, bits32, bits32, bool)
BINARYOP (fgt, v1 >  v2, v1,v2, float64, float64, bool, bits64, bits64, bool)
BINARYOP (fle, v1 <= v2, v1,v2, float32, float32, bool, bits32, bits32, bool)
BINARYOP (fle, v1 <= v2, v1,v2, float64, float64, bool, bits64, bits64, bool)
BINARYOP (flt, v1 <  v2, v1,v2, float32, float32, bool, bits32, bits32, bool)
BINARYOP (flt, v1 <  v2, v1,v2, float64, float64, bool, bits64, bits64, bool)
BINARYOP (fne, v1 != v2, v1,v2, float32, float32, bool, bits32, bits32, bool)
BINARYOP (fne, v1 != v2, v1,v2, float64, float64, bool, bits64, bits64, bool)
BINARYOP (fordered,   notnanf(v1) && notnanf(v2), v1,v2, float32, float32, bool,
                                                  bits32, bits32, bool) 
BINARYOP (fordered,   notnan(v1) && notnan(v2), v1,v2, float64, float64, bool,
                                                  bits64, bits64, bool) 
BINARYOP (funordered, cmm_isnanf(v1) || cmm_isnanf(v2), v1,v2, float32, float32, bool,
                                                  bits32, bits32, bool)
BINARYOP (funordered, cmm_isnan(v1) || cmm_isnan(v2), v1,v2, float64, float64, bool,
                                                  bits64, bits64, bool)
UNARYOP  (NaN, (float32) LOOPHOLE(u_int32, float32, (v1 & 0x7fffff) | 0x7f800000), v1, u_int32, float32, bits23, bits32)
OP64(UNARYOP  (NaN, (float64) LOOPHOLE(u_int64, float64, (v1 & 0xfffffffffffffLL) | 0x7ff0000000000000LL), v1, u_int64, float64, bits52, bits64))
NULLARYOP   (round_down,    { v1 = CMM_ROUND_DOWN;    },  v1, u_int8, bits2)
NULLARYOP   (round_up,      { v1 = CMM_ROUND_UP;      },  v1, u_int8, bits2)
NULLARYOP   (round_nearest, { v1 = CMM_ROUND_NEAREST; },  v1, u_int8, bits2)
NULLARYOP   (round_zero,    { v1 = CMM_ROUND_ZERO;    },  v1, u_int8, bits2)
RMUNARYOP   (f2f  , (float64) v1  , v1, float32, float64, bits32, bits64)
RMUNARYOP   (f2f  , (float32) v1  , v1, float64, float32, bits64, bits32)
RMUNARYOP   (f2i  , cmm_nearbyintf(v1), v1, float32, s_int32, bits32, bits32)
RMUNARYOP   (f2i  , cmm_nearbyint (v1), v1, float64, s_int32, bits64, bits32)
RMUNARYOP   (i2f  , (float32) v1  , v1, s_int32, float32, bits32, bits32)
RMUNARYOP   (i2f  , (float64) v1  , v1, s_int32, float64, bits32, bits64)
T_RMBINARYOP(fadd , v1 + v2       , v1, v2, float32, bits32)
T_RMBINARYOP(fadd , v1 + v2       , v1, v2, float64, bits64)
T_RMBINARYOP(fsub , v1 - v2       , v1, v2, float32, bits32)
T_RMBINARYOP(fsub , v1 - v2       , v1, v2, float64, bits64)
T_RMBINARYOP(fdiv , v1 / v2       , v1, v2, float32, bits32)
T_RMBINARYOP(fdiv , v1 / v2       , v1, v2, float64, bits64)
T_RMBINARYOP(fmul , v1 * v2       , v1, v2, float32, bits32)
T_RMBINARYOP(fmul , v1 * v2       , v1, v2, float64, bits64)
BINARYOP    (fmulx, (float64) v1 * (float64) v2, v1, v2, 
                    float32, float32, float64, bits32, bits32, bits64)
#define FABS(v) (sizeof(v) == sizeof(float)  ? cmm_fabsf(v) : \
                 sizeof(v) == sizeof(double) ? fabs(v)  : \
                 (assert(0),0.0))
T_UNARYOP   (fabs , FABS(v1), v1, float32, bits32)
T_UNARYOP   (fabs , FABS(v1), v1, float64, bits64)
#undef FABS
T_UNARYOP   (fneg , -(v1),                        v1, float32, bits32)
T_UNARYOP   (fneg , -(v1),                        v1, float64, bits64)
T_RMUNARYOP (fsqrt, (assert(sizeof(float )==(32/8)), cmm_sqrtf(v1)) , v1, float32, bits32)
T_RMUNARYOP (fsqrt, (assert(sizeof(double)==(64/8)), sqrt (v1)) , v1, float64, bits64)
NULLARYOP   (minf , { v1 = (float32) (-1.0/0.0); }, v1, float32, bits32)
NULLARYOP   (mzero, { v1 = (float32)       -0.0; }, v1, float32, bits32)
NULLARYOP   (pinf , { v1 = (float32)  (1.0/0.0); }, v1, float32, bits32)
NULLARYOP   (pzero, { v1 = (float32)        0.0; }, v1, float32, bits32)  
NULLARYOP   (minf , { v1 = (float64) (-1.0/0.0); }, v1, float64, bits64)
NULLARYOP   (mzero, { v1 = (float64)       -0.0; }, v1, float64, bits64)
NULLARYOP   (pinf , { v1 = (float64)  (1.0/0.0); }, v1, float64, bits64)
NULLARYOP   (pzero, { v1 = (float64)        0.0; }, v1, float64, bits64)  
/* FLOAT operators end here. */
@ 
% ----------------------------------------------------------------------------
\subsubsection{Integer Operators}
% ----------------------------------------------------------------------------

As with the floating-point operations, we write one macro call per
integer operation specified in the {\PAL} documentation. 
<<integer operator definitions>>=
/* INTEGER operators begin here. */
T_BINARYOP(add,     v1 + v2             , v1, v2,s_int16,bits16)
OVERFLOWOP(add,     +, signed           , v1, v2,s_int32,bits32)
T_BINARYOP(add,     v1 + v2             , v1, v2,s_int32,bits32)
WEIRDOP   (addc,    v1 + v2 + (c&0x01)  , v1, v2, c,u_int32,u_int32,bits32,bits32)
T_BINARYOP(and,     v1 & v2             , v1, v2,u_int16,bits16)
T_BINARYOP(and,     v1 & v2             , v1, v2,u_int32,bits32)
UNARYOP   (bit,     v1 & 0x01           , v1    ,bool   ,u_int1,bool  ,bits1 )
/* bitExtract  */
/* bitInsert   */
/* bitTransfer */
T_UNARYOP (lobits,  v1                  , v1    ,u_int32,bits32)
UNARYOP   (lobits,  v1 & 0xffff         , v1    ,u_int32,u_int16,bits32,bits16)
UNARYOP   (lobits,  v1 & 0xff           , v1    ,u_int32,u_int8 ,bits32,bits8 )
UNARYOP   (lobits,  v1 & 0xff           , v1    ,u_int16,u_int8 ,bits16,bits8 )
UNARYOP   (lobits,  v1 & 0x01           , v1    ,u_int32,u_int1 ,bits32,bits1 )
UNARYOP   (bool,    v1 & 0x01           , v1    ,u_int1 ,bool   ,bits1 ,bool  )
WEIRDOP   (borrow,   LL64((((ull) v1 - (ull) v2 - (ull) (c&0x01)) >> 32) != 0), \
                                          v1, v2, c,u_int32,u_int1,bits32,bits1)
WEIRDOP   (carry,    \
  LL64((u_int32) (((ull) v1 + (ull) v2 + (ull) (c&0x01)) >> 32)), \
                                          v1, v2, c,u_int32,u_int1,bits32,bits1)
T_UNARYOP (com,     ~v1                 , v1    ,u_int16,bits16)
T_UNARYOP (com,     ~v1                 , v1    ,u_int32,bits32)
T_BINARYOP(conjoin, (v1 & 0x01 ? v2 & 0x01 : 0)  , v1, v2,bool   ,bits1 )
T_BINARYOP(disjoin, (v1 & 0x01 ? 1 : v2 & 0x01)  , v1, v2,bool   ,bits1 )
IBINARYOP (div, { div_t temp = div(v1, v2);
                  ans = (temp.quot < 0 ? temp.quot - (temp.rem > 0)
                                       : temp.quot + (temp.rem > 0));
                },    v1,v2,ans, u_int32, u_int32,u_int32,bits32,bits32,bits32)
BINARYOP  (div_overflows, v2 == -1 && v1 == (1 << 31), \
                          v1,v2, u_int32, u_int32, bool,bits32,bits32,bool)
BINARYOP  (divu,v1 / v2,  v1,v2, u_int16, u_int16,u_int16,bits16,bits16,bits16)
BINARYOP  (divu,v1 / v2,  v1,v2, u_int32, u_int32,u_int32,bits32,bits32,bits32)
BINARYOP  (eq,  v1 == v2, v1,v2, u_int8 , u_int8 ,bool   ,bits2 ,bits2 ,bool  )
BINARYOP  (eq,  v1 == v2, v1,v2, u_int16, u_int16,bool   ,bits16,bits16,bool  )
BINARYOP  (eq,  v1 == v2, v1,v2, u_int32, u_int32,bool   ,bits32,bits32,bool  )
NULLARYOP (false, v1 = 0;, v1, bool, bool)
BINARYOP  (ge,  v1 >= v2, v1,v2, s_int16, s_int16,bool   ,bits16,bits16,bool  )
BINARYOP  (ge,  v1 >= v2, v1,v2, s_int32, s_int32,bool   ,bits32,bits32,bool  )
BINARYOP  (geu, v1 >= v2, v1,v2, u_int16, u_int16,bool   ,bits16,bits16,bool  )
BINARYOP  (geu, v1 >= v2, v1,v2, u_int32, u_int32,bool   ,bits32,bits32,bool  )
BINARYOP  (gt,  v1 >  v2, v1,v2, s_int16, s_int16,bool   ,bits16,bits16,bool  )
BINARYOP  (gt,  v1 >  v2, v1,v2, s_int32, s_int32,bool   ,bits32,bits32,bool  )
BINARYOP  (gtu, v1 >  v2, v1,v2, u_int16, u_int16,bool   ,bits16,bits16,bool  )
BINARYOP  (gtu, v1 >  v2, v1,v2, u_int32, u_int32,bool   ,bits32,bits32,bool  )
BINARYOP  (le,  v1 <= v2, v1,v2, s_int16, s_int16,bool   ,bits16,bits16,bool  )
BINARYOP  (le,  v1 <= v2, v1,v2, s_int32, s_int32,bool   ,bits32,bits32,bool  )
BINARYOP  (leu, v1 <= v2, v1,v2, u_int16, u_int16,bool   ,bits16,bits16,bool  )
BINARYOP  (leu, v1 <= v2, v1,v2, u_int32, u_int32,bool   ,bits32,bits32,bool  )
BINARYOP  (lt,  v1 <  v2, v1,v2, s_int16, s_int16,bool   ,bits16,bits16,bool  )
BINARYOP  (lt,  v1 <  v2, v1,v2, s_int32, s_int32,bool   ,bits32,bits32,bool  )
BINARYOP  (ltu, v1 <  v2, v1,v2, u_int16, u_int16,bool   ,bits16,bits16,bool  )
BINARYOP  (ltu, v1 <  v2, v1,v2, u_int32, u_int32,bool   ,bits32,bits32,bool  )
T_BINARYOP (mod, hand_mod(v1, v2), v1,v2, u_int32,bits32)
T_BINARYOP (modu, v1 % v2, v1,v2, u_int16,bits16)
T_BINARYOP (modu, v1 % v2, v1,v2, u_int32,bits32)

/* multiplication */
T_BINARYOP(mul  ,v1 * v2, v1,v2, s_int8 , bits8 )
T_BINARYOP(mul  ,v1 * v2, v1,v2, s_int16, bits16)
T_BINARYOP(mul  ,v1 * v2, v1,v2, s_int32, bits32)
OVERFLOWOP(mul,*,signed, v1, v2, s_int32, bits32)
OVERFLOWOP(mulu,*,unsigned, v1, v2, u_int32, bits32)
BINARYOP  (mulx ,v1 * v2, v1,v2, s_int8 , s_int8 ,s_int16,bits8 ,bits8 ,bits16)
BINARYOP  (mulx ,v1 * v2, v1,v2, s_int16, s_int16,s_int32,bits16,bits16,bits32)
OP64(BINARYOP  (mulx ,(s_int64) v1 * (s_int64) v2, v1,v2, s_int32, s_int32,s_int64,bits32,bits32,bits64))
BINARYOP  (mulux,v1 * v2, v1,v2, u_int8 , u_int8 ,u_int16,bits8 ,bits8 ,bits16)
BINARYOP  (mulux,v1 * v2, v1,v2, u_int16, u_int16,u_int32,bits16,bits16,bits32)
OP64(BINARYOP  (mulux ,(u_int64) v1 * (u_int64) v2, v1,v2, u_int32, u_int32,u_int64,bits32,bits32,bits64))

BINARYOP  (ne,   v1 !=v2, v1,v2, u_int8 , u_int8 ,bool   ,bits2 ,bits2 ,bool  )
BINARYOP  (ne,   v1 !=v2, v1,v2, u_int16, u_int16,bool   ,bits16,bits16,bool  )
BINARYOP  (ne,   v1 !=v2, v1,v2, u_int32, u_int32,bool   ,bits32,bits32,bool  )
T_UNARYOP (neg,     -v1                 , v1     ,s_int16,bits16)
T_UNARYOP (neg,     -v1                 , v1     ,s_int32,bits32)
T_UNARYOP (not,     !(v1 & 0x01)        , v1     ,bool   ,bits1 )
T_BINARYOP(or ,     v1 | v2             , v1, v2 ,u_int16,bits16)
T_BINARYOP(or ,     v1 | v2             , v1, v2 ,u_int32,bits32)
POPCNT    (u_int16, bits16)
POPCNT    (u_int32, bits32)

BINARYOP  (quot, v1 / v2, v1,v2, s_int16,s_int16,s_int16,bits16,bits16,bits16)
BINARYOP  (quot, v1 / v2, v1,v2, s_int32,s_int32,s_int32,bits32,bits32,bits32)
BINARYOP  (quot_overflows, v2 == -1 && v1 == (1 << 31), \
                             v1,v2, u_int32, u_int32, bool,bits32,bits32,bool)
BINARYOP  (rem,  v1 % v2, v1,v2, s_int16,s_int16,s_int16,bits16,bits16,bits16)
BINARYOP  (rem,  v1 % v2, v1,v2, s_int32,s_int32,s_int32,bits32,bits32,bits32)

ROTL      (u_int16, bits16)
ROTL      (u_int32, bits32)
ROTR      (u_int16, bits16)
ROTR      (u_int32, bits32)
@ 
We perform logical right shifts by viewing our arguments as unsigned
integers.
But to perform an arithmetic right shift, we cannot use a C~shift;
according to the C language definition, right-shifting a signed value [[v1]] 
by [[v2]] number of bits ([[v1 >> v2]]) is non-portable, and the result value is
up to the language implementor.
Accordingly, we add a mask explicitly.
few steps of arithmetic.
<<integer operator definitions>>=
T_BINARYOP(shl ,    v1 << v2          , v1, v2, u_int16, bits16)
T_BINARYOP(shl ,    v1 << v2          , v1, v2, u_int32, bits32)
T_BINARYOP(shra,    v2 == 0 ? v1 : v1 & 0x8000 ? (v1 >> v2) | (0xffff @<< (16-v2)) : v1 >> v2,
                                        v1, v2, u_int16, bits16)
T_BINARYOP(shra,    v2 == 0 ? v1 : v1 & 0x80000000 ? (v1 >> v2) | (0xffffffff @<< (32-v2)) : v1 >> v2,
                                        v1, v2, u_int32, bits32)
T_BINARYOP(shrl,    v1 >> v2          , v1, v2, u_int16, bits16)
T_BINARYOP(shrl,    v1 >> v2          , v1, v2, u_int32, bits32)
T_BINARYOP(sub ,    v1 - v2           , v1, v2, s_int16, bits16)
T_BINARYOP(sub ,    v1 - v2           , v1, v2, s_int32, bits32)
WEIRDOP   (subb,    v1 - v2 - (b&0x01), v1, v2, b,s_int32,s_int32,bits32,bits32)
OVERFLOWOP(sub,     -, signed        , v1, v2, s_int32, bits32)
UNARYOP   (sx  ,    (s_int16) v1      , v1, s_int8 , s_int16, bits8 , bits16)
UNARYOP   (sx  ,    ((s_int32) v1 @<< 31) @>> 31, \
                                        v1, u_int1 , s_int32, bits1 , bits32)
UNARYOP   (sx  ,    (s_int32) v1      , v1, s_int8 , s_int32, bits8 , bits32)
UNARYOP   (sx  ,    (s_int32) v1      , v1, s_int16, s_int32, bits16, bits32)
UNARYOP   (sx  ,    (s_int32) v1      , v1, s_int32, s_int32, bits32, bits32)
NULLARYOP (true, v1 = 1;, v1, bool, bool)
T_BINARYOP(xor ,    v1 ^ v2           , v1, v2, s_int16, bits16)
T_BINARYOP(xor ,    v1 ^ v2           , v1, v2, s_int32, bits32)
UNARYOP   (zx  ,    v1&0x01 ? 1 : 0   , v1, u_int1 , u_int32, bits1 , bits32)
UNARYOP   (zx  ,    (u_int16) v1      , v1, u_int8 , u_int16, bits8 , bits16)
UNARYOP   (zx  ,    (u_int32) v1      , v1, u_int8 , u_int32, bits8 , bits32)
UNARYOP   (zx  ,    (u_int32) v1      , v1, u_int16, u_int32, bits16, bits32)
UNARYOP   (zx  ,    (u_int32) v1      , v1, u_int32, u_int32, bits32, bits32)
/* INTEGER operators end here. */
@ 
% ----------------------------------------------------------------------------
\subsection{Operator Registration}
% ----------------------------------------------------------------------------

The main method of registering operators is through the use of helper function
[[register_operator]].
This function takes the name of an operator, a pointer to its implementation,
the number of arguments it takes, and an operator signature, and creates an
[[operator]] structure to represent the given operator instantiation.
This [[operator]] is then stored away in the global (Lua) table
[[operator_table]].
Note that [[register_operator]] will soundlessly re-register an instantiation
of an operator if the same operator name and signature are sent to it more
than once.
<<function definitions>>=
static void register_operator(const char *name,  operator_fun f, 
                              unsigned num_args, const char *sig)
{
  table     op_family = fresh_table();
  lua_State *L        = operator_table.L;
  operator  *op       = operator_new();

  op_family.L  = L;

  op->opname   = Atom_string(name);
  op->f        = f;
  op->num_args = num_args;

  lua_pushtable(L, operator_table);
  lua_pushstring(L, name);
  lua_gettable(L, -2);
  if (!lua_isnumber(L, -1)) {
    lua_pop(L, 1);        /* pop bogus value */
    lua_pushtable(L, op_family);
    lua_pushstring(L, name);
    lua_pushnumber(L, (double) op_family.data);
    lua_settable(L, -4);  /* store ref to op_family in operator_table */
  } else { 
    op_family.data = (unsigned) lua_tonumber(L, -1);
    lua_pop(L, 1);
    lua_pushtable(L, op_family);
  }
  /* op_family is on top, beneath which is operator_table */
  lua_pushstring(L, sig);
  lua_pushusertag(L, (operator *) op, lua_operator_tag);
  lua_settable(L, -3);

  lua_pop(L, 2); /* pop both tables */
}
@ 
To register all operators we have so far, we use [[init_operators]].
<<function definitions>>=
void init_operators(void) {
  <<operator macro redefinition>>
  <<floating-point operator definitions>>
  <<integer operator definitions>>

  <<set global Lua value [[CMM.tables.operators]] equal to [[operator_table]]>>
}
@ 
To allow a user to access a list of those operators we register at runtime,
we export [[operator_table]] as the Lua global value [[CMM.tables.operators]].
<<set global Lua value [[CMM.tables.operators]] equal to [[operator_table]]>>=
  table_exporttolua(lua_interpreter, &operator_table, "operators");
@ 
And now for the hackery that lets us define and register operators with the
same piece of code.
The [[#undef]]s are bad style, but they allow us to keep our operator
instantiation definitions in one place; it could easily become a nightmare 
if we had to keep operator definitions in one place and operator registrations
in another place.
<<operator macro redefinition>>=
#undef BINARYOP
#undef RMBINARYOP
#undef UNARYOP
#undef WEIRDOP
#undef RMUNARYOP
#undef IBINARYOP
#undef NULLARYOP
#undef POPCNT

#define BINARYOP(NAME, EXP, X, Y, TX, TY, T, BX, BY, B) \
register_operator(#NAME, op_##NAME##_##BX##_##BY##_##B, 2, #BX "," #BY ":" #B);

#define WEIRDOP(NAME, EXP, X, Y, Z, TXY, T, BXY, B) \
register_operator(#NAME, op_##NAME##_##BXY##_##BXY##_bits1_##B, 2, #BXY "," #BXY ",bits1:" #B);

#define RMBINARYOP(NAME, EXP, X, Y, TX, TY, T, BX, BY, B) \
register_operator(#NAME, op_##NAME##_##BX##_##BY##_bits2_##B, 3, \
                         #BX "," #BY ",bits2:" #B);

#define UNARYOP(NAME, EXP, X, TX, T, BX, B) \
register_operator(#NAME, op_##NAME##_##BX##_##B, 1, #BX ":" #B);

#define RMUNARYOP(NAME, EXP, X, TX, T, BX, B) \
register_operator(#NAME, op_##NAME##_##BX##_bits2_##B, 2, #BX ",bits2:" #B);

#define IBINARYOP(NAME, STMS, X, Y, RES, TX, TY, T, BX, BY, B) \
register_operator(#NAME, op_##NAME##_##BX##_##BY##_##B, 2, #BX "," #BY ":" #B);

#define NULLARYOP(NAME, STMS, X, T, B) \
register_operator(#NAME, op_##NAME##_##B,  0, ":" #B);

#define POPCNT(T, B) \
register_operator("popcnt", op_popcnt_##B, 1, #B ":" #B);
@ 
% ----------------------------------------------------------------------------
\subsection{Operator-Generation Macros}
% ----------------------------------------------------------------------------

An operator implementation function must do the following: take in a pointer
to a value stack, pop some number of values off the stack (possibly 0), 
perform some computations, and push the result value atop the stack.
Most operators fall into three categories: binary operators, unary operators, 
and nullary operators.
Additionally, binary and unary operators come in a few different kinds: those
whose arguments and return value share the same type, those whose arguments 
and return value differ in type, and those that take a hardware rounding-mode
specification as a last argument.
We write several macros to generate function definitions for members of these 
categories of operators, as well as a few others for some of the operators
that cannot be easily defined with these first macros.
[[BINARYOP]] and [[UNARYOP]] look nearly the same; they generate functions
that do underflow checks, perform an expression-based computation with the top
two (or one) values on the value stack, and place the result atop the value
stack--all the while ensuring that values are interpreted using the correct C
and {\PAL} types.

[[RMUNARYOP]] and [[RMBINARYOP]] look for a 2-bit rounding-mode specification
as a last argument to an operator; use of these macros allows us to omit
information about the rounding-mode operand in our definition of such
operators.
<<macro definitions>>=
#define BINARYOP(NAME, EXP, X, Y, TX, TY, T, BX, BY, B) \
\
valstack op_##NAME##_##BX##_##BY##_##B (valstack values) { \
  TY Y;                                      \
  TX X;                                      \
  UNDERFLOW_CHECK(values, 2);                \
  Y = VIEW(STACK_ELT(values,  0).TY, TY);    \
  X = VIEW(STACK_ELT(values, -1).TX, TX);    \
  VIEW(STACK_ELT(values, -1).T, T) = (EXP);  \
  values.s_free--;                           \
  return values;                             \
}

#define RMBINARYOP(NAME, EXP, X, Y, TX, TY, T, BX, BY, B) \
\
valstack op_##NAME##_##BX##_##BY##_bits2_##B (valstack values) { \
  TY Y;                                      \
  TX X;                                      \
  u_int8 _rmode;                             \
  UNDERFLOW_CHECK(values, 3);                \
  _rmode = VIEW(STACK_ELT(values,  0).bits2, u_int8); \
  Y = VIEW(STACK_ELT(values, -1).TY, TY);    \
  X = VIEW(STACK_ELT(values, -2).TX, TX);    \
  VIEW(STACK_ELT(values, -2).T, T) = (EXP);  \
  values.s_free -= 2;                        \
  return values;                             \
}

#define UNARYOP(NAME, EXP, X, TX, T, BX, B)  \
\
valstack op_##NAME##_##BX##_##B (valstack values) { \
  TX X;                                      \
  UNDERFLOW_CHECK(values, 1);                \
  X = VIEW(STACK_ELT(values, 0).TX, TX);     \
  VIEW(STACK_ELT(values, 0).T, T) = (EXP);   \
  return values;                             \
}

#define RMUNARYOP(NAME, EXP, X, TX, T, BX, B) \
\
valstack op_##NAME##_##BX##_bits2_##B (valstack values) {  \
  TX X;                                      \
  u_int8 _rmode;                             \
  UNDERFLOW_CHECK(values, 2);                \
  _rmode = VIEW(STACK_ELT(values, 0).bits2, u_int8); \
  X = VIEW(STACK_ELT(values, -1).TX, TX);    \
  VIEW(STACK_ELT(values, -1).T, T) = (EXP);  \
  values.s_free--;                           \
  return values;                             \
}
@ 
A weird operator takes a third, one-bit argument.
<<macro definitions>>=
#define WEIRDOP(NAME, EXP, X, Y, Z, TXY, T, BXY, B) \
\
valstack op_##NAME##_##BXY##_##BXY##_bits1_##B (valstack values) { \
  TXY X;                                              \
  TXY Y;                                              \
  u_int1 Z;                                          \
  UNDERFLOW_CHECK(values, 3);                        \
  Y = VIEW(STACK_ELT(values,  0).TXY, TXY);          \
  X = VIEW(STACK_ELT(values, -1).TXY, TXY);          \
  Z = VIEW(STACK_ELT(values, -2).u_int1, u_int1);    \
  VIEW(STACK_ELT(values, -2).T, T) = (EXP);          \
  values.s_free -= 2;                                \
  return values;                                     \
}
@ 
[[NULLARYOP]] and [[IBINARYOP]] are similar, but perform the result
computation imperatively (allowing for arbitrary code execution of [[STMS]]).
Note that [[IBINARYOP]] takes an extra argument ([[RES]]) -- the name of the
variable into which the operator's result will be placed.

<<macro definitions>>=
#define NULLARYOP(NAME, STMS, X, T, B) \
\
valstack op_##NAME##_##B (valstack values) { \
  T X;                                     \
  OVERFLOW_CHECK(values, 1);               \
  STMS                                     \
  VIEW(STACK_ELT(values, 1).T, T) = X;     \
  values.s_free++;                         \
  return values;                           \
}

/* IBINARYOP is an imperative form of BINARYOP; destroys value at values */
#define IBINARYOP(NAME, STMS, X, Y, RES, TX, TY, T, BX, BY, B)  \
\
valstack op_##NAME##_##BX##_##BY##_##B (valstack values) { \
  TX X;                                      \
  TY Y;                                      \
  T  RES;                                    \
  UNDERFLOW_CHECK(values, 2);                \
  Y = VIEW(STACK_ELT(values,  0).TY, TY);    \
  X = VIEW(STACK_ELT(values, -1).TX, TX);    \
  STMS;                                      \
  VIEW(STACK_ELT(values, -1).T, T) = RES;    \
  values.s_free--;                           \
  return values;                             \
}
@ 
[[T_BINARYOP]], [[T_UNARYOP]], and [[T_IBINARYOP]] are wrapper macros for
their cousins; they require fewer type information arguments because they
assume that all operator arguments share the same type with the operator
return value.
Similarly for [[T_RMUNARYOP]] and [[T_RMBINARYOP]].
<<macro synonyms>>=
#define T_BINARYOP(NAME, EXP, X, Y, T, B)    \
BINARYOP(NAME, EXP, X, Y, T, T, T, B, B, B)

#define T_RMBINARYOP(NAME, EXP, X, Y, T, B)   \
RMBINARYOP(NAME, EXP, X, Y, T, T, T, B, B, B)

#define T_UNARYOP(NAME, EXP, X, T, B)        \
UNARYOP(NAME, EXP, X, T, T, B, B)

#define T_RMUNARYOP(NAME, EXP, X, T, B)       \
RMUNARYOP(NAME, EXP, X, T, T, B, B)

#define T_IBINARYOP(NAME, STMS, X, Y, RES, T, B)  \
IBINARYOP(NAME, STMS, X, Y, RES, T, T, T, B, B, B)
@ 
Finally, we write a few extra macros for operators whose return value
computations require type-specific information.
By writing these as macros, we make it much easier to instantiate these
operators at different types.
<<macro definitions>>=
/* POPCNT generates a function that implements bit-counting;
   T is a C type, B is a C-- type
 */
#define POPCNT(T, B) \
valstack op_popcnt##_##B (valstack values) { \
  T v, count;                              \
  UNDERFLOW_CHECK(values, 1);              \
  v = VIEW(STACK_ELT(values, 0).T, T);     \
  for ( ; v != 0; v >>= 1)                 \
    count += (v & 1);                      \
  VIEW(STACK_ELT(values, 0).T, T) = count; \
  return values;                           \
}
@ 
These ROTx macros generate functions to implement bit-rotation;
   T is a C type, B is a C-- type
<<macro synonyms>>=
#define ROTL(T, B) \
T_BINARYOP(rotl, (x @<< d) + (((~(((T) ~0) >> d)) & x) @>> (sizeof(T)*8 - d)),\
                 x, d, T, B)
#define ROTR(T, B) \
T_BINARYOP(rotr, (x >>  d) + (((~(((T) ~0) << d)) & x) << (sizeof(T)*8 - d)),\
                 x, d, T, B)
@ 
There's a certain pattern to some of the overflow operators.
<<macro synonyms>>=
#define OVERFLOWOP(NAME, OP, SIGNED, X, Y, T, B)   \
  BINARYOP  (NAME##_overflows,  \
             LL64 ((SIGNED long long) (X OP Y) != \
                      (SIGNED long long) X OP (SIGNED long long) Y), \
             X, Y, T, T, bool, B, B, bool) 
@ 
Implementation of [[mod]] taken from Moscow~ML.
<<function definitions>>=
static int hand_mod(int x, int y) {
  int tmp, answer;
  tmp = y;
  assert (tmp != 0);
  if( tmp < 0 ) { x = -x; tmp = -tmp; }
  if( x >= 0 ) {
    answer = x % tmp;
  } else {
    x = (-x) % tmp;
    answer = ( x == 0 )?( 0 ):( tmp - x );
  }
  if( y < 0 ) answer = -answer;
  return answer;
}
<<internal function prototypes>>=
static int hand_mod(int x, int y);
@ 
<<function definitions>>=
