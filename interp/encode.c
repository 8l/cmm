/* Generated by the New Jersey Machine-Code Toolkit, version 0.5 */
/* command line: tools -lc-cons-names -encoder encode bytecode.sled */
#include <mclib.h>
#include "encode.h"
#define sign_extend(N,SIZE) \
  (((int)((N) << (sizeof(unsigned)*8-(SIZE)))) >> (sizeof(unsigned)*8-(SIZE)))
/**************

store_local8 bits8 is (?noname?) op ==  8; bits8 = bits8

***********/
void store_local8(unsigned /* [0..255] */ bits8) {
  if (!((unsigned)(bits8) < 0x100)) 
    fail("field bits8 does not fit in 8 unsigned bits"); 
  else 
    { emitm(8, 1); emitm(bits8 & 0xff, 1); } 
}
/**************

store_global8 bits8 is (?noname?) op ==  9; bits8 = bits8

***********/
void store_global8(unsigned /* [0..255] */ bits8) {
  if (!((unsigned)(bits8) < 0x100)) 
    fail("field bits8 does not fit in 8 unsigned bits"); 
  else 
    { emitm(9, 1); emitm(bits8 & 0xff, 1); } 
}
/**************

fetch_local8 bits8 is (?noname?) op == 10; bits8 = bits8

***********/
void fetch_local8(unsigned /* [0..255] */ bits8) {
  if (!((unsigned)(bits8) < 0x100)) 
    fail("field bits8 does not fit in 8 unsigned bits"); 
  else 
    { emitm(10, 1); emitm(bits8 & 0xff, 1); } 
}
/**************

fetch_global8 bits8 is (?noname?) op == 11; bits8 = bits8

***********/
void fetch_global8(unsigned /* [0..255] */ bits8) {
  if (!((unsigned)(bits8) < 0x100)) 
    fail("field bits8 does not fit in 8 unsigned bits"); 
  else 
    { emitm(11, 1); emitm(bits8 & 0xff, 1); } 
}
/**************

gstore_local8 bits8 is (?noname?) op == 16; bits8 = bits8

***********/
void gstore_local8(unsigned /* [0..255] */ bits8) {
  if (!((unsigned)(bits8) < 0x100)) 
    fail("field bits8 does not fit in 8 unsigned bits"); 
  else 
    { emitm(16, 1); emitm(bits8 & 0xff, 1); } 
}
/**************

gstore_global8 bits8 is (?noname?) op == 18; bits8 = bits8

***********/
void gstore_global8(unsigned /* [0..255] */ bits8) {
  if (!((unsigned)(bits8) < 0x100)) 
    fail("field bits8 does not fit in 8 unsigned bits"); 
  else 
    { emitm(18, 1); emitm(bits8 & 0xff, 1); } 
}
/**************

fetch_arg bits8 is (?noname?) op ==  6; bits8 = bits8

***********/
void fetch_arg(unsigned /* [0..255] */ bits8) {
  if (!((unsigned)(bits8) < 0x100)) 
    fail("field bits8 does not fit in 8 unsigned bits"); 
  else 
    { emitm(6, 1); emitm(bits8 & 0xff, 1); } 
}
/**************

store_arg bits8 is (?noname?) op ==  7; bits8 = bits8

***********/
void store_arg(unsigned /* [0..255] */ bits8) {
  if (!((unsigned)(bits8) < 0x100)) 
    fail("field bits8 does not fit in 8 unsigned bits"); 
  else 
    { emitm(7, 1); emitm(bits8 & 0xff, 1); } 
}
/**************

store_local16 bits16 is (?noname?) op == 12; bits16 = bits16

***********/
void store_local16(unsigned /* [0..65535] */ bits16) {
  if (!((unsigned)(bits16) < 0x10000)) 
    fail("field bits16 does not fit in 16 unsigned bits"); 
  else 
    { emitm(12, 1); emitm(bits16 & 0xffff, 2); } 
}
/**************

store_global16 bits16 is (?noname?) op == 13; bits16 = bits16

***********/
void store_global16(unsigned /* [0..65535] */ bits16) {
  if (!((unsigned)(bits16) < 0x10000)) 
    fail("field bits16 does not fit in 16 unsigned bits"); 
  else 
    { emitm(13, 1); emitm(bits16 & 0xffff, 2); } 
}
/**************

fetch_local16 bits16 is (?noname?) op == 14; bits16 = bits16

***********/
void fetch_local16(unsigned /* [0..65535] */ bits16) {
  if (!((unsigned)(bits16) < 0x10000)) 
    fail("field bits16 does not fit in 16 unsigned bits"); 
  else 
    { emitm(14, 1); emitm(bits16 & 0xffff, 2); } 
}
/**************

fetch_global16 bits16 is (?noname?) op == 15; bits16 = bits16

***********/
void fetch_global16(unsigned /* [0..65535] */ bits16) {
  if (!((unsigned)(bits16) < 0x10000)) 
    fail("field bits16 does not fit in 16 unsigned bits"); 
  else 
    { emitm(15, 1); emitm(bits16 & 0xffff, 2); } 
}
/**************

gstore_local16 bits16 is (?noname?) op == 17; bits16 = bits16

***********/
void gstore_local16(unsigned /* [0..65535] */ bits16) {
  if (!((unsigned)(bits16) < 0x10000)) 
    fail("field bits16 does not fit in 16 unsigned bits"); 
  else 
    { emitm(17, 1); emitm(bits16 & 0xffff, 2); } 
}
/**************

gstore_global16 bits16 is (?noname?) op == 19; bits16 = bits16

***********/
void gstore_global16(unsigned /* [0..65535] */ bits16) {
  if (!((unsigned)(bits16) < 0x10000)) 
    fail("field bits16 does not fit in 16 unsigned bits"); 
  else 
    { emitm(19, 1); emitm(bits16 & 0xffff, 2); } 
}
/**************

call bits32 is (?noname?) op == 24; bits32 = bits32

***********/
void call(unsigned bits32) {
  { emitm(24, 1); emitm(bits32, 4); }
}
/**************

define_proc bits32 is (?noname?) op ==  0; bits32 = bits32

***********/
void define_proc(unsigned bits32) {
  { emitm(0, 1); emitm(bits32, 4); }
}
/**************

push_symbol bits32 is (?noname?) op == 29; bits32 = bits32

***********/
void push_symbol(unsigned bits32) {
  { emitm(29, 1); emitm(bits32, 4); }
}
/**************

fetch bits8  bits8b bits8c is 
  (?noname?) op ==  4; bits8 = bits8; bits8b = bits8b; bits8c = bits8c

***********/
void fetch(unsigned /* [0..255] */ bits8, unsigned /* [0..255] */ bits8b, unsigned /* [0..255] */ bits8c) {
  if (!((unsigned)(bits8) < 0x100)) 
    fail("field bits8 does not fit in 8 unsigned bits"); 
  else if (!((unsigned)(bits8b) < 0x100)) 
    fail("field bits8b does not fit in 8 unsigned bits"); 
  else if (!((unsigned)(bits8c) < 0x100)) 
    fail("field bits8c does not fit in 8 unsigned bits"); 
  else 
    { 
      emitm(4, 1); 
      emitm(bits8 & 0xff, 1); 
      emitm(bits8b & 0xff, 1); 
      emitm(bits8c & 0xff, 1); 
    } 
}
/**************

store bits8  bits8b bits8c is 
  (?noname?) op ==  5; bits8 = bits8; bits8b = bits8b; bits8c = bits8c

***********/
void store(unsigned /* [0..255] */ bits8, unsigned /* [0..255] */ bits8b, unsigned /* [0..255] */ bits8c) {
  if (!((unsigned)(bits8) < 0x100)) 
    fail("field bits8 does not fit in 8 unsigned bits"); 
  else if (!((unsigned)(bits8b) < 0x100)) 
    fail("field bits8b does not fit in 8 unsigned bits"); 
  else if (!((unsigned)(bits8c) < 0x100)) 
    fail("field bits8c does not fit in 8 unsigned bits"); 
  else 
    { 
      emitm(5, 1); 
      emitm(bits8 & 0xff, 1); 
      emitm(bits8b & 0xff, 1); 
      emitm(bits8c & 0xff, 1); 
    } 
}
/**************

gstore bits8  bits8b bits8c is 
  (?noname?) op ==  3; bits8 = bits8; bits8b = bits8b; bits8c = bits8c

***********/
void gstore(unsigned /* [0..255] */ bits8, unsigned /* [0..255] */ bits8b, unsigned /* [0..255] */ bits8c) {
  if (!((unsigned)(bits8) < 0x100)) 
    fail("field bits8 does not fit in 8 unsigned bits"); 
  else if (!((unsigned)(bits8b) < 0x100)) 
    fail("field bits8b does not fit in 8 unsigned bits"); 
  else if (!((unsigned)(bits8c) < 0x100)) 
    fail("field bits8c does not fit in 8 unsigned bits"); 
  else 
    { 
      emitm(3, 1); 
      emitm(bits8 & 0xff, 1); 
      emitm(bits8b & 0xff, 1); 
      emitm(bits8c & 0xff, 1); 
    } 
}
/**************

emit_raddr addr is (?noname?) bits32 = addr

***********/
typedef struct O1_0_closure {
  ClosureHeader h;
  ClosureLocation loc;
  struct {  RAddr a1; } v;
} *O1_0_Closure;
static void O1_0_relocfn(RClosure c, RelocCallback f, void *closure) {
  O1_0_Closure _c = (O1_0_Closure) c;
  (*f)(closure, _c->v.a1);
  }
/* CLOSURE FUNCTION _clofun_1 is 
  1 cla force cl-loc force 4 emit-at
  
 */
/* bytecode (3) is "\x15\x85\x00" */
static void _clofun_1(RClosure c, Emitter emitter, FailCont fail) {
  O1_0_Closure _c = (O1_0_Closure) c;
  
  emitter(_c->loc.dest_block, _c->loc.dest_lc, location(_c->v.a1), 4);
  
}
static struct closure_header _clofun_1_closure_header = 
  { _clofun_1, O1_0_relocfn, 0, sizeof (struct O1_0_closure) };
/****************
CLOSURE IS: CLOSURE(
    type = O1_0, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {}, 
    addresses = {addr})
****************/
void emit_raddr(RAddr addr) {
  if (location_known(addr)) 
    
    emitm(location(addr), 4); 
  else 
    { 
      { O1_0_Closure _c;
        _c = (O1_0_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.a1 = addr;
        /* this line intentionally left blank */
      }  
       
      emitm(0, 4); 
    } 
}
/**************

push bits32 bits8 is (?noname?) op ==  2; bits32 = bits32; bits8 = bits8

***********/
void push(unsigned bits32, unsigned /* [0..255] */ bits8) {
  if (!((unsigned)(bits8) < 0x100)) 
    fail("field bits8 does not fit in 8 unsigned bits"); 
  else 
    { emitm(2, 1); emitm(bits32, 4); emitm(bits8 & 0xff, 1); } 
}
/**************

apply_operator bits32 is (?noname?) op == 30; bits32 = bits32

***********/
void apply_operator(unsigned bits32) {
  { emitm(30, 1); emitm(bits32, 4); }
}
/**************

cbrancht addr is (?noname?) op == 21; bits32 = addr

***********/
/* CLOSURE FUNCTION _clofun_2 is 
  21 cl-loc force 1 emit-at
  1 cla force cl-loc force 1 add 4 emit-at
  
 */
/* bytecode (10) is "U\x15\x05\x15\x0f_\eCo\x00" */
static void _clofun_2(RClosure c, Emitter emitter, FailCont fail) {
  O1_0_Closure _c = (O1_0_Closure) c;
  
  { 
    emitter(_c->loc.dest_block, _c->loc.dest_lc, 21, 1); 
    emitter(_c->loc.dest_block, _c->loc.dest_lc + 1, location(_c->v.a1), 4); 
  }
  
}
static struct closure_header _clofun_2_closure_header = 
  { _clofun_2, O1_0_relocfn, 0, sizeof (struct O1_0_closure) };
/****************
CLOSURE IS: CLOSURE(
    type = O1_0, 
    fun = _clofun_2, 
    header = _clofun_2_closure_header, 
    values = {}, 
    addresses = {addr})
****************/
void cbrancht(RAddr addr) {
  if (location_known(addr)) 
    { emitm(21, 1); emitm(location(addr), 4); } 
  else 
    { 
      { O1_0_Closure _c;
        _c = (O1_0_Closure) mc_create_closure_here(sizeof *_c, &_clofun_2_closure_header);
        _c->v.a1 = addr;
        /* this line intentionally left blank */
      }  
       
      { emitm(34, 1); emitm(0, 4); } 
    } 
}
/**************

cbranchf addr is (?noname?) op == 22; bits32 = addr

***********/
/* CLOSURE FUNCTION _clofun_3 is 
  22 cl-loc force 1 emit-at
  1 cla force cl-loc force 1 add 4 emit-at
  
 */
/* bytecode (10) is "U\x16\x05\x15\x0f_\eCo\x00" */
static void _clofun_3(RClosure c, Emitter emitter, FailCont fail) {
  O1_0_Closure _c = (O1_0_Closure) c;
  
  { 
    emitter(_c->loc.dest_block, _c->loc.dest_lc, 22, 1); 
    emitter(_c->loc.dest_block, _c->loc.dest_lc + 1, location(_c->v.a1), 4); 
  }
  
}
static struct closure_header _clofun_3_closure_header = 
  { _clofun_3, O1_0_relocfn, 0, sizeof (struct O1_0_closure) };
/****************
CLOSURE IS: CLOSURE(
    type = O1_0, 
    fun = _clofun_3, 
    header = _clofun_3_closure_header, 
    values = {}, 
    addresses = {addr})
****************/
void cbranchf(RAddr addr) {
  if (location_known(addr)) 
    { emitm(22, 1); emitm(location(addr), 4); } 
  else 
    { 
      { O1_0_Closure _c;
        _c = (O1_0_Closure) mc_create_closure_here(sizeof *_c, &_clofun_3_closure_header);
        _c->v.a1 = addr;
        /* this line intentionally left blank */
      }  
       
      { emitm(34, 1); emitm(0, 4); } 
    } 
}
/**************

branchtf addr   addr2 is (?noname?) op == 23; bits32 = addr; bits32 = addr2

***********/
typedef struct O2_0_closure {
  ClosureHeader h;
  ClosureLocation loc;
  struct {  RAddr a1; RAddr a2; } v;
} *O2_0_Closure;
static void O2_0_relocfn(RClosure c, RelocCallback f, void *closure) {
  O2_0_Closure _c = (O2_0_Closure) c;
  (*f)(closure, _c->v.a1);
  (*f)(closure, _c->v.a2);
  }
/* CLOSURE FUNCTION _clofun_4 is 
  23 cl-loc force 1 emit-at
  1 cla force cl-loc force 1 add 4 emit-at
  2 cla force cl-loc force 5 add 4 emit-at
  
 */
/* bytecode (16) is "U\x17\x05\x15\x0f_\eCo\x95\x0f_[Co\x00" */
static void _clofun_4(RClosure c, Emitter emitter, FailCont fail) {
  O2_0_Closure _c = (O2_0_Closure) c;
  
  { 
    emitter(_c->loc.dest_block, _c->loc.dest_lc, 23, 1); 
    emitter(_c->loc.dest_block, _c->loc.dest_lc + 1, location(_c->v.a1), 4); 
    emitter(_c->loc.dest_block, _c->loc.dest_lc + 5, location(_c->v.a2), 4); 
  }
  
}
static struct closure_header _clofun_4_closure_header = 
  { _clofun_4, O2_0_relocfn, 0, sizeof (struct O2_0_closure) };
/****************
CLOSURE IS: CLOSURE(
    type = O2_0, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {}, 
    addresses = {addr, addr2})
****************/
void branchtf(RAddr addr, RAddr addr2) {
  if (location_known(addr) && location_known(addr2)) 
    { emitm(23, 1); emitm(location(addr), 4); emitm(location(addr2), 4); } 
  else 
    { 
      { O2_0_Closure _c;
        _c = (O2_0_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.a1 = addr;
        _c->v.a2 = addr2;
        /* this line intentionally left blank */
      }  
       
      { emitm(34, 1); emitm(0, 4); emitm(0, 4); } 
    } 
}
/**************

return bits8  bits8b is (?noname?) op == 26; bits8 = bits8; bits8b = bits8b

***********/
void return_(unsigned /* [0..255] */ bits8, unsigned /* [0..255] */ bits8b) {
  if (!((unsigned)(bits8) < 0x100)) 
    fail("field bits8 does not fit in 8 unsigned bits"); 
  else if (!((unsigned)(bits8b) < 0x100)) 
    fail("field bits8b does not fit in 8 unsigned bits"); 
  else 
    { emitm(26, 1); emitm(bits8 & 0xff, 1); emitm(bits8b & 0xff, 1); } 
}
/**************

halt  is (HALT) op == 36

***********/
void halt(void) {
  emitm(36, 1);
}
/**************

goto  is (GOTO) op == 20

***********/
void goto_(void) {
  emitm(20, 1);
}
/**************

cmm_tail_call  is (CMM_TAIL_CALL) op == 25

***********/
void cmm_tail_call(void) {
  emitm(25, 1);
}
/**************

cut  is (CUT) op == 27

***********/
void cut(void) {
  emitm(27, 1);
}
/**************

end_proc  is (END_PROC) op ==  1

***********/
void end_proc(void) {
  emitm(1, 1);
}
/**************

fetch_round  is (FETCH_ROUND) op == 31

***********/
void fetch_round(void) {
  emitm(31, 1);
}
/**************

store_round  is (STORE_ROUND) op == 32

***********/
void store_round(void) {
  emitm(32, 1);
}
/**************

fetch_sp  is (FETCH_SP) op == 33

***********/
void fetch_sp(void) {
  emitm(33, 1);
}
/**************

breakpt  is (BREAKPT) op == 35

***********/
void breakpt(void) {
  emitm(35, 1);
}
/**************

forbidden  is (FORBIDDEN) op == 37

***********/
void forbidden(void) {
  emitm(37, 1);
}
/**************

store_local bits16 is 
  (store_local8) op ==  8; bits8 = bits16 
  | (store_local16) op == 12; bits16 = bits16

***********/
void store_local(unsigned /* [0..65535] */ bits16) {
  if (!((unsigned)(bits16) < 0x10000)) 
    fail("field bits16 does not fit in 16 unsigned bits"); 
  else 
    if ((unsigned)(bits16) < 0x100) 
      { emitm(8, 1); emitm(bits16 & 0xff, 1); } 
    else 
      { emitm(12, 1); emitm(bits16 & 0xffff, 2); }  
}
/**************

store_global bits16 is 
  (store_global8) op ==  9; bits8 = bits16 
  | (store_global16) op == 13; bits16 = bits16

***********/
void store_global(unsigned /* [0..65535] */ bits16) {
  if (!((unsigned)(bits16) < 0x10000)) 
    fail("field bits16 does not fit in 16 unsigned bits"); 
  else 
    if ((unsigned)(bits16) < 0x100) 
      { emitm(9, 1); emitm(bits16 & 0xff, 1); } 
    else 
      { emitm(13, 1); emitm(bits16 & 0xffff, 2); }  
}
/**************

gstore_local bits16 is 
  (gstore_local8) op == 16; bits8 = bits16 
  | (gstore_local16) op == 17; bits16 = bits16

***********/
void gstore_local(unsigned /* [0..65535] */ bits16) {
  if (!((unsigned)(bits16) < 0x10000)) 
    fail("field bits16 does not fit in 16 unsigned bits"); 
  else 
    if ((unsigned)(bits16) < 0x100) 
      { emitm(16, 1); emitm(bits16 & 0xff, 1); } 
    else 
      { emitm(17, 1); emitm(bits16 & 0xffff, 2); }  
}
/**************

gstore_global bits16 is 
  (gstore_global8) op == 18; bits8 = bits16 
  | (gstore_global16) op == 19; bits16 = bits16

***********/
void gstore_global(unsigned /* [0..65535] */ bits16) {
  if (!((unsigned)(bits16) < 0x10000)) 
    fail("field bits16 does not fit in 16 unsigned bits"); 
  else 
    if ((unsigned)(bits16) < 0x100) 
      { emitm(18, 1); emitm(bits16 & 0xff, 1); } 
    else 
      { emitm(19, 1); emitm(bits16 & 0xffff, 2); }  
}
/**************

fetch_local bits16 is 
  (fetch_local8) op == 10; bits8 = bits16 
  | (fetch_local16) op == 14; bits16 = bits16

***********/
void fetch_local(unsigned /* [0..65535] */ bits16) {
  if (!((unsigned)(bits16) < 0x10000)) 
    fail("field bits16 does not fit in 16 unsigned bits"); 
  else 
    if ((unsigned)(bits16) < 0x100) 
      { emitm(10, 1); emitm(bits16 & 0xff, 1); } 
    else 
      { emitm(14, 1); emitm(bits16 & 0xffff, 2); }  
}
/**************

fetch_global bits16 is 
  (fetch_global8) op == 11; bits8 = bits16 
  | (fetch_global16) op == 15; bits16 = bits16

***********/
void fetch_global(unsigned /* [0..65535] */ bits16) {
  if (!((unsigned)(bits16) < 0x10000)) 
    fail("field bits16 does not fit in 16 unsigned bits"); 
  else 
    if ((unsigned)(bits16) < 0x100) 
      { emitm(11, 1); emitm(bits16 & 0xff, 1); } 
    else 
      { emitm(15, 1); emitm(bits16 & 0xffff, 2); }  
}

/*****************************
  _clofun_2 = 
    21 cl-loc force 1 emit-at
    1 cla force cl-loc force 1 add 4 emit-at
    
  _clofun_3 = 
    22 cl-loc force 1 emit-at
    1 cla force cl-loc force 1 add 4 emit-at
    
  _clofun_4 = 
    23 cl-loc force 1 emit-at
    1 cla force cl-loc force 1 add 4 emit-at
    2 cla force cl-loc force 5 add 4 emit-at
    
  _clofun_1 = 
    1 cla force cl-loc force 4 emit-at
    
  
****************/
ClosurePostfix encode_clofuns[] = {
  { _clofun_2, "21 cl-loc force 1 emit-at\n1 cla force cl-loc force 1 add 4 emit-at\n" }, 
  { _clofun_3, "22 cl-loc force 1 emit-at\n1 cla force cl-loc force 1 add 4 emit-at\n" }, 
  { _clofun_4, "23 cl-loc force 1 emit-at\n1 cla force cl-loc force 1 add 4 emit-at\n2 cla force cl-loc force 5 add 4 emit-at\n" }, 
  { _clofun_1, "1 cla force cl-loc force 4 emit-at\n" }, 
  { (ApplyMethod) 0, (char *) 0 }
};
ClosurePostfix encode_clobytes[] = {
  { _clofun_2, /* 9 */ "U\x15\x05\x15\x0f_\eCo" }, 
  { _clofun_3, /* 9 */ "U\x16\x05\x15\x0f_\eCo" }, 
  { _clofun_4, /* 15 */ "U\x17\x05\x15\x0f_\eCo\x95\x0f_[Co" }, 
  { _clofun_1, /* 2 */ "\x15\x85" }, 
  { (ApplyMethod) 0, (char *) 0 }
};

/* Bytecode total is 35 */
