% -*- mode: Noweb; noweb-code-mode: c-mode -*- %

\ifx\nointro\undefined
This document contains the interface and implementation of the interpreter's encoding phase.
\fi

% ----------------------------------------------------------------------------
\interface{[[encoding]] : Bytecode Generation and Loading}
% ----------------------------------------------------------------------------

<<encoding.h>>=
#ifndef _ENCODING_H
#define _ENCODING_H

#include <lua.h>
#include "table.h"

<<macro definitions>>
<<macro-generated function prototypes>>

#endif /* _ENCODING_H */
@ 

The C functions that implement bytecode encoding are tied to the Lua functions described in [[manual.nw]].
These functions are all of the same general format: they take in a [[lua_State *]], expect some number of elements (perhaps even 0) atop the Lua stack, emit an instruction bytecode into the [[RBlock]] representing the current {\PAL} [[section]], and return the number of values they leave atop the Lua stack (which should be 0 in every case).  

We use macros to ``deal'' with these functions, some of which also happen to be macro-generated.
The macro [[ITERATE_CMM_FUNCS(F)]] iterates through each of the instructions in the interpreter's abstract machine, applying the argument macro [[F]] to it.
To generate function prototypes for the encoding functions, we use macro [[LUA_FUNC_PROTOTYPE]] with this iterator.

We need not reproduce the generated prototypes here, as they are largely uninteresting; there is a C function for each of the Lua functions listed in the interpreter's user guide ([[manual.nw]]).
These functions maintain the same behavior as their Lua counterparts, and they are named according to the same convention: a Lua function [[CMM.]]$x$ is implemented by the C function [[lua_CMM_]]$x$.
It should be sufficient to show a few examples of what the prototypes might look like:

<<sample macro-generated prototypes>>=
int    lua_CMM_section(lua_State *L);
int    lua_CMM_goto(lua_State *L);
...    ...
@ 

The other macro used with [[ITERATE_CMM_FUNCS]] is the [[LUA_FUNC_REGISTER]]
macro, which is used by [[main]] to register these Lua-style C functions with
Lua.
Some of these Lua-style C functions are implemented manually, while a number
are generated with use of the macros [[LUA_WRAP_NULLARY(FUNC, LUANAME)]] and 
[[LUA_WRAP_UNARY_INDEX(FUNC, LUANAME)]].
[[LUA_WRAP_NULLARY]] wraps a nullary encoding function [[FUNC]] generated by
the New Jersey Machine-Code Toolkit into a Lua-style C function named 
[[lua_CMM_LUANAME]] (where [[LUANAME]] is replaced by the macro's second
argument).
For more information on these C encoding functions generated by the toolkit, please see the implementation section of the [[encoding]] module.

% ----------------------------------------------------------------------------
\paragraph{{\PAL} Sections}
% ----------------------------------------------------------------------------

Each uniquely identified {\PAL} section is represented by a relocatable block
([[RBlock]]).
The bytecode for all source code within a section is stored within the 
section's [[RBlock]].
A Lua table is used to maintain a list of all named sections, and all code at 
the toplevel of the source file (not within a named {\PAL} section) are stored
in a special [[RBlock]].
Functions [[lua_CMM_section]] and [[lua_CMM_end_section]] implement 
section-handling, and are exported to Lua as explained below.  
We do not supply the real prototypes for these functions here, for they are
macro generated at compile-time.

<<faux prototypes>>=
int lua_CMM_section(lua_State *L);
int lua_CMM_end_section(lua_State *L);
@ 

% ----------------------------------------------------------------------------
\implementation{Bytecode Generation and Loading}
% ----------------------------------------------------------------------------

<<encoding.c>>=
#include "encoding.h"

#include <assert.h>
#include <mclib.h>
#include <string.h>
#include <strings.h>
#include <stdlib.h>

#include "assemblyunit.h"
#include "controlflow.h"
#include "encode.h"
#include "label.h"
#include "lualink.h"
#include "operator.h"
#include "interp.h"
#include "span.h"
#include "util.h"

#include <cii/atom.h>
#include <cii/mp.h>

<<bytecode generation>>
@

% ----------------------------------------------------------------------------
\subsection{Externally Defined Globals}
% ----------------------------------------------------------------------------

During encoding, we need to be able to find the current [[assembly_unit]] .
These global variables are defined in other files, and are declared as
[[extern]]s in header files [[assemblyunit.h]] and [[controlflow.h]].
We write faux declarations for them here so we do not forget about them.

<<faux declarations for external definitions>>=
extern assembly_unit *unit;
@ 

% ----------------------------------------------------------------------------
\subsection{Lua Export Macros}
% ----------------------------------------------------------------------------

Exporting our encoding functions to Lua tends to involve simple function
wrapping (wrapping a C function generated by the toolkit in a Lua-style C
function that manipulates the Lua stack to access arguments).
We make use of a few macros for some of these wrapper functions.
[[LUA_WRAP_NULLARY]] simply ensures there are 0 elements on the Lua stack,
calls the wrapped C function, and returns 0 to tell Lua that it produced no
return value (each of the Toolkit-generated functions returns no value to Lua).

<<macro definitions>>=
/* these macros help out with wrapping C functions in Lua-style C functions
   as well as registering these functions with Lua */
#define LUA_WRAP_NULLARY(FUNC, LUANAME) \
\
int lua_CMM_##LUANAME (lua_State *L) {             \
  if (lua_gettop(L) != 0)                          \
    cmm_err(#FUNC " is a nullary function!");   \
  FUNC();                                          \
  return 0;                                        \
}
@ 

[[LUA_WRAP_UNARY_INDEX]] makes sure there is a Lua number atop the Lua stack,
casts it to an [[unsigned]] C value, calls the wrapped function with this
value, pops the value off the Lua stack, and returns 0 to indicate no value
was returned to Lua.

<<macro definitions>>=
#define LUA_WRAP_UNARY_INDEX(FUNC, LUANAME) \
int lua_CMM_##LUANAME (lua_State *L) {               \
  if (!lua_isnumber(L, -1))                          \
    cmm_err(#FUNC " requires an integer index!"); \
  FUNC((unsigned) lua_tonumber(L, -1));              \
  lua_pop(L, 1);                                     \
  return 0;                                          \
}
@

We write a special Lua-wrapper generating macro for those functions that
manipulate the argument-passing area; this allows us to get an accurate count
of how much space we need to allocate for this area.

<<macro definitions>>=
#define LUA_WRAP_UNARY_ARGS(FUNC, LUANAME) \
int lua_CMM_##LUANAME (lua_State *L) {               \
  unsigned index;                                    \
  if (!lua_isnumber(L, -1))                          \
    cmm_err(#FUNC " requires an integer index!");    \
  index = (unsigned) lua_tonumber(L, -1);            \
  if (index + 1 > max_args) max_args = index + 1;    \
  FUNC(index);                                       \
  lua_pop(L, 1);                                     \
  return 0;                                          \
}
@ 

It is useful to iterate through all the {\PAL} functions exported to Lua,
calling some macro on each function name, because we must generate prototypes
for all of these functions' Lua-style C implementations and we must also 
register all of these C functions with Lua.
The macro lets us do both in one place.

[[ITERATE_CMM_FUNCS]] iterates through the functions that have been
implemented by calling argument macro [[F]] on each one.

<<macro definitions>>=
#define ITERATE_CMM_FUNCS(F) \
F(comment) \
F(breakpt) \
\
F(new_assembly_unit) \
\
F(section) \
F(end_section) \
F(define_label) \
F(procedure) \
F(end_procedure) \
F(begin_span) \
F(end_span) \
\
F(ptrsize) \
F(memsize) \
F(byteorder) \
F(imports) \
F(exports) \
F(globals) \
\
F(align) \
F(skip) \
F(data) \
F(emit_raddr) \
\
F(fetch_sp) \
F(push_literal) \
F(push_symbol) \
F(fetch) \
F(fetch_local) \
F(fetch_global) \
F(gstore) \
F(store) \
F(store_local) \
F(store_global) \
F(gstore_local) \
F(gstore_global) \
\
F(apply_operator) \
F(fetch_rounding) \
F(store_rounding) \
\
F(fetch_arg) \
F(store_arg) \
F(goto) \
F(cbrancht) \
F(cbranchf) \
F(branchtf) \
F(call) \
F(cmm_tail_call) \
F(cmm_return) \
F(cut) \
F(forbidden)
@

Now we write macros that may be used with [[ITERATE_CMM_FUNCS]]: one to
generate a prototype for each function and the other to register the functions
with Lua.

<<macro definitions>>=
#define LUA_FUNC_PROTOTYPE(X) \
int lua_CMM_##X (lua_State *L);

#define LUA_FUNC_REGISTER(X) \
lua_CMM_register(lua_interp, #X, (lua_CFunction) lua_CMM_##X);

#define lua_CMM_register(L, LUANAME, CNAME) \
(lua_getglobal(L, "CMM"),     lua_pushstring(L, LUANAME), \
 lua_pushcfunction(L, CNAME), lua_settable(L, -3),        \
 lua_pop(L, 1))
@ 

% ----------------------------------------------------------------------------
\subsection{Exported Encoding Functions}
% ----------------------------------------------------------------------------

Now, we must export the encoding functions the Toolkit provides us to Lua.

\subsubsection{Demarcating Assembly Units}

We provide an exported Lua function to mark the beginning of a new assembly
unit.
This allows us to concatenate multiple Lua assembly units and store them in
one file that may be loaded all at once.

Note that this function need not be called from Lua for the first assembly
unit in a source file; our default behavior includes creating a new assembly
unit when we load in a new file anyway.
<<bytecode generation>>=
int lua_CMM_new_assembly_unit(lua_State *L) {
  enter_new_assembly_unit(L);
  return 0;
}
@ 

\subsubsection{Structure Related Encoding}

Each {\PAL} section is given its own relocatable block, with all code from the
toplevel unnamed section being placed in a special relocatable block.  
In [[lua_CMM_section]], we maintain a Lua table that maps section labels to
their respective blocks.  
Remember also that sections with the same label are effectively concatenated
and placed together in memory.

<<bytecode generation>>=
int lua_CMM_section(lua_State *L) {
  RBlock section_block = NULL;

  /* if the stack is empty we assume we should enter the default sect. */
  if (lua_gettop(L) == 0) {
    <<enter the default section's [[RBlock]]>>
    return 0;
  }

  /* if we get down here, there must have been a key string on the stack */
  lua_assert_isstring(L, -1, "section names must be strings");
  lua_pushtable(L, unit->section_table);

  lua_insert(L, -2);     /* swap stack positions of key string and table */
  lua_pushvalue(L, -1);  /* make copy of key string atop table */
  lua_gettable(L, -3);   /* look up string to see if section is defined  */
  if (lua_isuserdata(L, -1) &&
      lua_tag(L, -1) == lua_RBlock_tag && 
      (section_block = (RBlock) lua_touserdata(L, -1)) != NULL)
  {
    assert(block_defined(section_block));
    set_block(section_block);
    lua_pop(L, 3);       /* pop off RBlock address, key string copy, table */
  } else {
    <<create new [[RBlock]] and store in section table>>
  }

  return 0;              /* this function pushes 0 results onto Lua stack */
}
@ 
<<enter the default section's [[RBlock]]>>=
    if (unit->def_section != NULL) {
      assert(block_defined(unit->def_section));
      set_block(unit->def_section);
    } else {
      unit->def_section = block_new(0);
      assert(block_defined(unit->def_section));
      set_block(unit->def_section);
    }
@
<<create new [[RBlock]] and store in section table>>=
    section_block = block_new(0);
    assert(block_defined(section_block));
    set_block(section_block);

    lua_pop(L, 1);       /* pop nil off */
    lua_pushusertag(L, (void *) section_block, lua_RBlock_tag);
    lua_settable(L, -3); /* pops off RBlock address, key string copy */

    lua_pop(L, 1);       /* pop off table */
@
[[lua_CMM_section]] considers the ending of a {\PAL} section to be equivalent
to the entering of the default, toplevel section.
As such, [[lua_CMM_end_section]] simply calls [[lua_CMM_section]] with no
arguments on the stack (which [[lua_CMM_section]] treats as an attempt to
enter the default section).
Note that [[lua_CMM_end_section]] must empty the Lua stack in order to do this;
be careful.
<<bytecode generation>>=
int lua_CMM_end_section(lua_State *L) {
  /* remove anything on the stack */
  lua_pop(L, lua_gettop(L));
  return lua_CMM_section(L);
}
@
[[lua_CMM_procedure]] expects four arguments atop the Lua stack: a {\PAL} 
procedure's name, the number of local variables in the procedure, the size
of local stack-data in the procedure (in [[memsize]] units), and
a table of offsets for stackdata labels.
This function effectively pops these values off the stack, creates a new C
[[procedure]] structure encapsulating necessary information about the {\PAL}
procedure, associates a [[CMM_label]] with this procedure by way of a call to
[[label]] module helper function [[get_label]], and returns 0 to tell Lua
no value is being returned.
<<bytecode generation>>=
int lua_CMM_procedure(lua_State *L) {
  const char *name;
  procedure  *proc;
  CMM_label  *lbl;

  /* this function takes three arguments: 

     1. the procedure's name
     2. the number of local vars in the proc
     3. the size of stackdata in the proc
     4. table of offsets for stackdata labels
   */
  lua_assert_istable (L, -1,
                     "must specify offsets for stackdata labels");
  lua_assert_isnumber(L, -2, 
                    "must specify size of stackdata within C-- procedure");
  lua_assert_isnumber(L, -3,
                    "must specify number of local variables in C-- procedure");
  lua_assert_isstring(L, -4,
                    "cannot define anonymous procedures in C--");

  <<[[lbl]] $\leftarrow$ [[CMM_label]] for the procedure>>  

  lua_pop(L, 4);  /* pop off 4 arguments */

  /* we've now defined at least one symbol */
  unit->definitions_yet = 1;

  /* emit instruction */
  define_proc((unsigned) proc);

  return 0;
}
@ 
<<[[lbl]] $\leftarrow$ [[CMM_label]] for the procedure>>=
  name = Atom_string(lua_tostring(L, -4));

  lua_pushvalue(L, -4);       /* make copy of procedure name */
  lbl  = get_label(L, name);

  if (CMM_label_defined(lbl)) {
    cmm_err_wstr("cannot define procedure [%s]; "
                 "a label by that name already exists", name);
  }

  /* see if someone else referenced this label as a procedure */
  if (lbl->ty == CMM_PROCEDURE && lbl->lbl.proc != NULL)
    proc = lbl->lbl.proc;
  else /* otherwise allocate a new procedure struct */
    proc = procedure_new();

  /* initialize procedure struct */
  proc->raddr          = lbl->lbl.raddr;
  label_define(proc->raddr->label, 0);
  proc->num_locals     = (unsigned int) lua_tonumber(L, -3);
  proc->stackdata_size = (unsigned int) lua_tonumber(L, -2);

  <<copy stackdata label table into [[proc->stackdata_labels]]>>

  lbl->unit = unit;
  lbl->ty = CMM_PROCEDURE;
  lbl->lbl.proc = proc;
@

Nothing too interesting happens to copy the table.
<<copy stackdata label table into [[proc->stackdata_labels]]>>=
{
  int i, n;

  proc->stackdata_labels = fresh_table();
  n = lua_getn(L, -1);
  lua_pushtable(L, proc->stackdata_labels);

  for (i = 1; i <= n; i++) { 
    lua_rawgeti(L, -2, i);
    lua_assert_isnumber(L, -1, "stackdata label offsets must be numbers");
    lua_rawseti(L, -2, i);
  }

  lua_pop(L, 1);  /* pop off proc->stackdata_labels */
} 
@ 

To define a label, we call on helper function [[get_label]] to take care of
namespace bookkeeping.
Whether or not there were any previous references to this label in the program
being encoded, [[get_label]] returns the [[CMM_label]] structure associated
with the relocatable label to be associated with this label.
We then call the toolkit API function [[label_define]] to link the label with
the current location in the current relocatable block.
If we instead find the label is already linked with a location in an
[[RBlock]], we send an error to the user; we do not allow label redefinition.

<<bytecode generation>>=
int lua_CMM_define_label(lua_State *L) {
  const char *name;
  RLabel     label;
  RAddr      addr;
  CMM_label  *lbl;

  /* we expect a key string */
  lua_assert_isstring(L, -1, "cannot define a nameless label in C--");

  name  = Atom_string(lua_tostring(L, -1));
  lbl   = get_label(L, name);

  if (lbl->ty != CMM_LABEL) {
    cmm_err("label type mismatch (a label may have been used as a procedure)");
  }
  
  addr  = lbl->lbl.raddr;
  label = addr->label;

  if (!CMM_label_defined(lbl)) {
    label_define(label, 0);
    lbl->unit = unit;
  } else
    cmm_err_wstr("cannot redefine label [%s]", name);

  /* we've now defined at least one symbol */
  unit->definitions_yet = 1;

  return 0;
}
@

The encoding of spans is mostly farmed out to helper functions in the [[span]]
module.
[[lua_CMM_begin_span]] expects three arguments on the Lua stack: a token (a 
string), a string value (a {\PAL} label), and an offset (from the label value).
[[lua_CMM_end_span]] expects one argument atop the Lua stack: a token (a 
string).
Both functions return 0 to indicate to Lua that they return no values.

<<bytecode generation>>=
int lua_CMM_begin_span(lua_State *L) {
  const char *value_lbl;
  int         lbl_offset;
  unsigned    tok;

  lua_assert_isnumber(L, -1, "begin_span requires an offset as its 3rd arg.");
  lua_assert_isstring(L, -2, "begin_span requires a value as its 2nd arg.");
  lua_assert_isnumber(L, -3, "begin_span requires a token as its 1st arg.");

  lbl_offset = (int) lua_tonumber(L, -1);
  value_lbl  = lua_tostring(L, -2);
  tok        = (unsigned) lua_tonumber(L, -3);
  
  lua_pop(L, 3); /* pop token, value */

  /* enter span */
  span_table_begin(span_table, tok, value_lbl, lbl_offset);
  return 0;
}
int lua_CMM_end_span(lua_State *L) {
  unsigned tok;

  lua_assert_isnumber(L, -1, "end_span requires a token as its only argument");

  tok = (unsigned) lua_tonumber(L, -1);
  lua_pop(L, 1); /* pop token */

  /* enter span */
  span_table_end(span_table, tok);
  return 0;
}
@ 

Finally, we allow ``variable-argument'' comments.
We simply throw away the arguments.

<<bytecode generation>>=
int lua_CMM_comment(lua_State *L) {
  lua_pop(L, lua_gettop(L));
  return 0;
}
@ 

% ----------------------------------------------------------------------------
\subsubsection{Toplevel Declaration Encoding}
% ----------------------------------------------------------------------------

There are a number of declarations that may be made no more than once per
assembly unit, and only so at the toplevel of a source file (not within a
section).

[[lua_CMM_imports]] and [[lua_CMM_exports]] define the {\PAL} symbols imported
into and exported from the current assembly unit, respectively.
We require that a label being imported must first have been exported by another
assembly unit (or perhaps by the front-end runtime system).

<<bytecode generation>>=
int lua_CMM_imports(lua_State *L) {
  static assembly_unit *last_au = NULL;
  unsigned imports, exports;

  if (unit->definitions_yet)
    cmm_err("must declare imports before defining any symbols");
  if (last_au == unit)
    cmm_err("cannot declare imports more than once per assembly unit");
  if (crb() != unit->def_section)
    cmm_err("cannot declare imports from within a C-- section");
  
  last_au = unit;

  lua_assert_istable(L, -1, "imports expects a table of symbols as strings");

  /* add imports to the current unit's label table */
  imports = lua_gettop(L);
  lua_pushtable(L, exports_table);
  exports = lua_gettop(L);
  lua_pushnil(L);
  while (lua_next(L, imports) != 0) {
    CMM_label  *lbl;
    const char *str = lua_tostring(L, -1);

    /* key is at -2, value is at -1 */
    lua_pushvalue(L, -1); /* duplicate value (label name) atop the stack */

    /* look for label in existing exports table */
    lua_gettable(L, exports);
    if (!lua_isuserdata(L, -1) ||
        lua_tag(L, -1) != lua_CMM_label_tag ||
        (lbl = (CMM_label *) lua_touserdata(L, -1)) == NULL)
    {
      /* if it's not yet defined in exports, we need to define it! */
      lua_pop(L, 1); /* pop whatever the value was */
      lbl = get_label(L, str);
      
      /* pop whatever the value was */
      lua_pushstring(L, str); /* push string */
      lua_pushusertag(L, (void *) lbl, lua_CMM_label_tag);
      lua_settable(L, exports);
    } else {
      /* otherwise, we grab the existing label and inform this unit about it */

      /* label string is at -2, CMM_label is at -1 */
      lua_pushtable(L, unit->label_table);
      lua_insert(L, -3); /* move table below string, label */
      lua_settable(L, -3);
      lua_pop(L, 1); /* pop the table */
    }
  }

  lua_pop(L, 2); /* pop 2 tables */
  assert(lua_gettop(L) == 0);

  return 0;
} 
@ 

[[lua_CMM_exports]] expects a table to be atop the Lua stack; the table should
contain the symbols (in string form) to be exported from this assembly unit.

<<bytecode generation>>=
int lua_CMM_exports(lua_State *L) {
  static assembly_unit *last_au = NULL;
  unsigned new_exports, old_exports;
  CMM_label *exported_label;

  if (unit->definitions_yet)
    cmm_err("must declare imports before defining any symbols");
  if (last_au == unit)
    cmm_err("cannot declare exports more than once per assembly unit");
  if (crb() != unit->def_section)
    cmm_err("cannot declare exports from within a C-- section");

  last_au = unit;

  lua_assert_istable(L, -1, "exports expects a table of symbols as strings");

  /* add exports to global export table */
  new_exports = lua_gettop(L);
  lua_pushtable(L, exports_table);
  old_exports = lua_gettop(L);
  lua_pushnil(L);
  while (lua_next(L, new_exports) != 0) {
    CMM_label *lbl;

    /* key is at -2, value is at -1 */
    lua_pushvalue(L, -1); /* duplicate value (label) atop the stack */
    
    /* see if another unit already referenced this symbol */
    lua_gettable(L, old_exports);
    if (lua_isuserdata(L, -1) && lua_tag(L, -1) == lua_CMM_label_tag &&
        (exported_label = (CMM_label *) lua_touserdata(L, -1)) != NULL) {
      /* if so, we just need to find the CMM_label */
      lua_pushtable(L, unit->label_table);
      lua_pushvalue(L, -3); /* push the string    */
      lua_pushvalue(L, -3); /* push the CMM_label */
      lua_settable(L, -3);  /* associate string w/CMM_label in table   */
      lua_pop(L, 3);        /* pop table, CMM_label, & original string */
      continue; /* we're done with this symbol now, proceed onwards */
    }

    lua_pop(L, 1);   /* pop nil */
    lua_pushvalue(L, -1); /* duplicate value (label) atop the stack again */
    lbl = get_label(L, lua_tostring(L, -1));

    lua_pushusertag(L, (void *) lbl, lua_CMM_label_tag);
    lua_settable(L, old_exports);
  }

  lua_pop(L, 2); /* pop 2 tables */
  assert(lua_gettop(L) == 0);

  return 0;
}
@

[[lua_CMM_ptrsize]], [[lua_CMM_memsize]], and [[lua_byteorder]] inform the
interpreter about the desired target architecture to be simulated.
For now, we simply generate an error and fail if a target architecture other
than the current one (of the machine on which this code is running) is 
specified.

<<bytecode generation>>=
int lua_CMM_ptrsize(lua_State *L) {
  static assembly_unit *last_au = NULL;

  unsigned ptrsize;

  if (last_au == unit)
    cmm_err("cannot declare PTRSIZE more than once per assembly unit");
  if (crb() != unit->def_section)
    cmm_err("cannot declare PTRSIZE from within a C-- section");

  last_au = unit;

  lua_assert_isnumber(L, -1, "PTRSIZE must be given as a number");
  ptrsize = (unsigned) lua_tonumber(L, -1);
  lua_pop(L, 1);

  unit->ptrsize = ptrsize;

  /* make sure we can handle this ptrsize */
  check_architecture(unit);

  return 0;
}
int lua_CMM_memsize(lua_State *L) {
  static assembly_unit *last_au = NULL;

  unsigned memsize;

  if (last_au == unit)
    cmm_err("cannot declare MEMSIZE more than once per assembly unit");
  if (crb() != unit->def_section)
    cmm_err("cannot declare MEMSIZE from within a C-- section");

  last_au = unit;

  lua_assert_isnumber(L, -1, "MEMSIZE must be given as a number");
  memsize = (unsigned) lua_tonumber(L, -1);
  lua_pop(L, 1);

  unit->memsize = memsize;

  /* make sure we can handle this memsize */
  check_architecture(unit);

  return 0;
}
int lua_CMM_byteorder(lua_State *L) {
  static assembly_unit *last_au = NULL;

  byte_order b;

  if (last_au == unit)
    cmm_err("cannot declare BYTEORDER more than once per assembly unit");
  if (crb() != unit->def_section)
    cmm_err("cannot declare BYTEORDER from within a C-- section");

  last_au = unit;

  lua_assert_isstring(L, -1, "BYTEORDER must be either \"LITTLE\", \"BIG\", "
                             "or \"NATIVE\"");

  if (string_match_case(lua_tostring(L, -1), "LITTLE"))       b = LITTLE;
  else if (string_match_case(lua_tostring(L, -1), "BIG"))     b = BIG;
  else if (string_match_case(lua_tostring(L, -1), "NATIVE"))  b = DEF_BYTE_ORDER;
  else
    cmm_err("BYTEORDER must be either \"LITTLE\", \"BIG\", or \"NATIVE\"");
 
  lua_pop(L, 1);  
  unit->byte_order = b;

  /* make sure we can handle this byteorder */
  check_architecture(unit);

  return 0;
}
@ 

[[lua_CMM_globals]] simply informs the interpreter of the number of global
variables used in the current assembly unit.
Its implementation is similar in structure to the previous
architecture-information encoding functions.

<<bytecode generation>>=
int lua_CMM_globals(lua_State *L) {
  static assembly_unit *last_au = NULL;
  int g;

  if (last_au == unit)
    cmm_err("cannot declare GLOBALS more than once per assembly unit");

  last_au = unit;

  lua_assert_isnumber(L, -1, "GLOBALS must be a number");
  g = (int) lua_tonumber(L, -1);
  lua_pop(L, 1); /* pop arg */

  if (num_globals != INVALID && g != num_globals)
    cmm_err("all assembly units must contain the same number of globals");
  if (g < 0)
    cmm_err("cannot declare a negative number of globals");
  if (num_globals > g) 
    cmm_err("C-- code makes use of more globals than GLOBALS declaration "
            "specifies");

  num_globals = g;

  return 0;
}
@ 

% ----------------------------------------------------------------------------
\subsubsection{Data Encoding}
% ----------------------------------------------------------------------------

To allow declarations of both initialized and uninitialized data, we provide 
[[lua_CMM_align]], [[lua_CMM_skip]], and [[lua_CMM_data]].

[[lua_CMM_align]] simply makes a call to the NJ Machine-Code Toolkit API 
function [[align]], which takes an [[unsigned n]] and aligns the current 
location counter in the current [[RBlock]] on an [[n]]-byte boundary.
Since [[lua_CMM_align]] expects its argument to be in terms of 
[[unit->memsize]], we must make sure to convert to bytes by multiplying out
and dividing by 8 (for 8 bits in a byte).

<<bytecode generation>>=
int lua_CMM_align(lua_State *L) {
  lua_assert_isnumber(L, -1, "align expects a number argument");
  align((unsigned) (((unsigned) lua_tonumber(L, -1)) * unit->memsize / 8));
  lua_pop(L, 1);
  return 0;
}
@ 

[[lua_CMM_skip]] calls toolkit API function [[addlc]] and returns no values to
Lua.

<<bytecode generation>>=
int lua_CMM_skip(lua_State *L) {
  lua_assert_isnumber(L, -1, "skip expects a number argument");
  addlc((unsigned) (((unsigned) lua_tonumber(L, -1)) * unit->memsize / 8));
  lua_pop(L, 1);
  return 0;
}
@ 

[[lua_CMM_data]] expects to see a bit-width specification and a possibly empty
table of initialized data.
If the table is empty, we simply leave some space for uninitialized data.
Otherwise, we create initialized data.

The data itself is expected to be in hexadecimal-string form.

<<bytecode generation>>=
int lua_CMM_data(lua_State *L) {
  unsigned bitsize;

  lua_assert_isnumber(L, -2, "data expects a bit-width as its 1st argument");
  bitsize = (unsigned) lua_tonumber(L, -2);

  assert(bitsize % 8 == 0); /* for now we assert bitwidth is mult. of 8 */

  /* for now, we emit data into memory only in the current machine's natural
   * byte-order
   */
  if (lua_istable(L, -1)) {
    int i, n;

    n = lua_getn(L, -1);
    for (i = 1; i <= n; i++) {
      unsigned long int num;
      lua_rawgeti(L, -1, i);

      lua_assert_isstring(L, -1, 
                    "data expects initialized arguments in string form (hex)");
      if (sscanf(lua_tostring(L, -1), "%lx", &num) != 1) {
        cmm_err("could not parse given initialized data");
      }

      emitm(num, bitsize / 8);
      lua_pop(L, 1);
    }
  } else if (lua_isnil(L, -1))
    addlc(bitsize / 8);
  else
    cmm_err("data expects either a table or nil as its 2nd argument");

  lua_pop(L, 2); /* pop both arguments */

  assert(lua_gettop(L) == 0);

  return 0;
}
@ 

To emit the address of a symbol, [[lua_CMM_emit_raddr]] lets the Toolkit do 
all the work (we emit the [[emit_raddr]] instruction with a [[RAddr]] argument,
which the Toolkit automagically changes to an actual address once it is known).

<<bytecode generation>>=
int lua_CMM_emit_raddr(lua_State *L) {
  CMM_label  *lbl;
  RAddr       found_raddr, raddr_to_emit;
  const char *sym;
  long int    offset;

  lua_assert_isstring(L, -1, "emit_raddr expects an offset (hex string)");
  lua_assert_isstring(L, -2, "emit_raddr expects a symbol name (string)");

  cmm_assert(sscanf(lua_tostring(L, -1), "%lx",
                      (unsigned long int *) (&offset)) == 1,
             "could not parse offset; hexadecimal string literal expected");
  lua_pop(L, 1);

  sym = Atom_string(lua_tostring(L, -1));
  lbl = get_label(L, sym);

  /* if label is a C function, we emit a pointer to its CMM_label  */
  if (lbl->ty == CMM_CFUNCTION) {
    /* RRO: will this have the desired effect with function pointers? */
    emitm((unsigned long) lbl, sizeof(void *));
    return 0;
  }

  found_raddr = CMM_label_raddr(lbl);
  assert(found_raddr != NULL);

  raddr_to_emit = (offset == 0 ? found_raddr 
                               : addr_new(found_raddr->label, offset));

  /* emit instruction */
  emit_raddr(raddr_to_emit);

  return 0;
}
@ 

% ----------------------------------------------------------------------------
\subsubsection{Instruction Encoding}
% ----------------------------------------------------------------------------

[[lua_CMM_push_literal]] looks for a string and a bit-width specification atop
the Lua stack, pops them off, parses the string as a [[long]] hexadecimal 
value, casts it to an unsigned 32-bit C integer, calls the encoding function
[[push]] with the value, and returns no values to Lua.

<<bytecode generation>>=
int lua_CMM_push_literal(lua_State *L) {
  long int num;
  unsigned width;
  MP_T     mp_num;

  lua_assert_isnumber(L, -1, "push_literal expects a width spec. (number)");
  lua_assert_isstring(L, -2, "push_literal expects a string literal (hex)");

  width = lua_tonumber(L, -1);

  /* FIX this should be more elegant */
  if (width > 32) {
    MP_set(width);
    mp_num = MP_new(0);
    mp_num = MP_fromstr(mp_num, lua_tostring(L, -2), 16, NULL);
    num    = (long int) mp_num;
  } else {
    cmm_assert(sscanf(lua_tostring(L, -2), "%lx", 
                        (unsigned long int *) (&num)) == 1,
               "could not parse literal; hexadecimal string literal expected");
  }

  /* emit instruction */
  push((unsigned) num, width);
  lua_pop(L, 2);

  return 0;
}
@

[[lua_CMM_push_symbol]] uses [[get_label]] to do the brunt of its work.
An error is produced if the symbol pushed currently has no attached value.

<<bytecode generation>>=
int lua_CMM_push_symbol(lua_State *L) {
  CMM_label  *lbl;
  const char *sym;

  lua_assert_isstring(L, -1, "push_symbol expects a string literal");
  sym = Atom_string(lua_tostring(L, -1));

  lbl = get_label(L, sym);

  /* RRO: should error-check type mismatches here?? */

  /* emit instruction */
  push_symbol((unsigned) lbl);

  return 0;
}
@ 

[[lua_CMM_fetch]] checks for three values atop the Lua stack: a numerical
bit-size, a string indicating bit order (valid options are [["BIG"]],
[["LITTLE"]], or [["NATIVE"]]), and a numerical alignment specification.
The endianness indication is converted into a [[byte_order]] value and then
[[fetch]] is called with the values.

<<bytecode generation>>=
int lua_CMM_fetch(lua_State *L) {
  unsigned   align, size;
  byte_order b;

  lua_assert_isnumber(L, -1, 
         "fetch requires a numerical alignment specification");
  lua_assert_isstring(L, -2, 
         "fetch requires a byte-order specification of \"BIG\", \"LITTLE\", "
         "or \"NATIVE\"");
  lua_assert_isnumber(L, -3, 
         "fetch requires a numerical bit-size specification");
  
  size  = (unsigned int) lua_tonumber(L, -3);
  if (string_match_case(lua_tostring(L, -2), "LITTLE"))       b = LITTLE;
  else if (string_match_case(lua_tostring(L, -2), "BIG"))     b = BIG;
  else if (string_match_case(lua_tostring(L, -2), "NATIVE"))  b = DEF_BYTE_ORDER;
  else cmm_err( 
         "fetch requires a byte-order specification of \"BIG\", \"LITTLE\", "
         "or \"NATIVE\"");

  align = (unsigned int) lua_tonumber(L, -1);
  if (align == 0) align = DEF_ALIGN;

  /* emit instruction */
  fetch(size, (unsigned) b, align);

  return 0;
}
@ 

[[lua_CMM_store]] and [[lua_CMM_gstore]] are identical to [[lua_CMM_fetch]], except for which bytecode emitters they call.

<<bytecode generation>>=
int lua_CMM_store(lua_State *L) {
  unsigned   align, size;
  byte_order b;

  lua_assert_isnumber(L, -1, 
         "store requires a numerical alignment specification");
  lua_assert_isstring(L, -2, 
         "store requires a byte-order specification of \"BIG\", \"LITTLE\", "
         "or \"NATIVE\"");
  lua_assert_isnumber(L, -3, 
         "store requires a numerical bit-size specification");
  
  size  = (unsigned int) lua_tonumber(L, -3);
  if (string_match_case(lua_tostring(L, -2), "LITTLE"))       b = LITTLE;
  else if (string_match_case(lua_tostring(L, -2), "BIG"))     b = BIG;
  else if (string_match_case(lua_tostring(L, -2), "NATIVE"))  b = DEF_BYTE_ORDER;
  else cmm_err( 
        "store requires a byte-order specification of \"BIG\", \"LITTLE\", "
        "or \"NATIVE\"");

  align = (unsigned int) lua_tonumber(L, -1);
  if (align == 0) align = DEF_ALIGN;

  /* emit instruction */
  store(size, (unsigned) b, align);

  return 0;
}

int lua_CMM_gstore(lua_State *L) {
  unsigned   size;
  byte_order b;
  unsigned   align;

  lua_assert_isnumber(L, -1, 
        "gstore requires a numerical alignment specification");
  lua_assert_isstring(L, -2, 
        "gstore requires a byte-order specification of \"BIG\", \"LITTLE\", "
        "or \"NATIVE\"");
  lua_assert_isnumber(L, -3, 
        "gstore requires a numerical bit-size specification");
  
  size  = (unsigned) lua_tonumber(L, -3);
  if (string_match_case(lua_tostring(L, -2), "LITTLE"))       b = LITTLE;
  else if (string_match_case(lua_tostring(L, -2), "BIG"))     b = BIG;
  else if (string_match_case(lua_tostring(L, -2), "NATIVE"))  b = DEF_BYTE_ORDER;
  else cmm_err( 
        "gstore requires a byte-order specification of \"BIG\", \"LITTLE\", "
        "or \"NATIVE\"");

  align = (unsigned) lua_tonumber(L, -1);
  if (align == 0) align = DEF_ALIGN;

  /* emit instruction */
  gstore(size, (unsigned) b, align);

  return 0;
}
@ 

[[lua_CMM_apply_operator]] expects two arguments: the stem name of an operator
(as a string), and a bit width specification for the operator's arguments and
return value.
The bit widths are specified as one string constant comprised of a
comma-delimited list of argument widths followed by a colon ([[:]]) and the
return value's width.
For example, [["bits32,bits16:bits8"]] signs an operator that takes a 32-bit
argument and a 16-bit argument and returns an 8-bit value.
If the the operator is nullary, the string should be of the form
[[":bits]]$k$[["]].

<<bytecode generation>>=
int lua_CMM_apply_operator(lua_State *L) {
  table       op_family = fresh_table();
  operator   *op;
  const char *opname, *wanted_widths;

  lua_assert_isstring(L, -1, 
             "apply_operator requires a bit-width specification");
  lua_assert_isstring(L, -2,
             "apply_operator requires an operator stem name (in string form)");

  opname        = lua_tostring(L, -2);
  wanted_widths = lua_tostring(L, -1);

  <<[[op_family]] $\leftarrow$ Lua table representing [[op_stem_name]]>>
  <<[[op]] $\leftarrow$ pointer to associated [[operator]] record>>

  apply_operator((unsigned) op);

  return 0;
}
@ 

Looking up the specified operator involves simple table manipulation.
We present the user with an error message if we cannot find a reference to the
operator (instantiation) specified.

<<[[op_family]] $\leftarrow$ Lua table representing [[op_stem_name]]>>=
  op_family.L = L;

  lua_pushtable(L, operator_table);
  lua_insert(L, -3); /* move operator_table below bit-widths and stem name */
  lua_insert(L, -2); /* swap bit-widths and stem name */
  lua_gettable(L, -3);

  lua_assert_isnumber(L, -1, "operator family has not been registered");
  op_family.data = (unsigned) lua_tonumber(L, -1);
  lua_pop(L, 1);
  lua_pushtable(L, op_family);
  lua_assert_istable(L, -1,"operator family has not been properly registered");
  lua_insert(L, -2); /* swap op_family and bit-widths */
@
<<[[op]] $\leftarrow$ pointer to associated [[operator]] record>>=
  /* bit-widths is on top, beneath which is op_family & then operator_table */
  lua_gettable(L, -2);

  if (!lua_isuserdata(L, -1) || 
      lua_tag(L, -1) != lua_operator_tag ||
      (op = (operator *) lua_touserdata(L, -1)) == NULL)
  {
    /* should we pop anything?? */
    fprintf(stderr, "error: tried to use operator '%s' at width '%s'\n",
                    opname, wanted_widths);
    cmm_err("operator "
            "is not instantiated at needed type signature");
  }

  lua_pop(L, 3);     /* pop op, op_family, operator_table */
  assert(lua_gettop(L) == 0);
@

[[lua_CMM_cbrancht]] and [[lua_CMM_cbranchf]] do the following: they check for
a string atop the Lua stack, copy it into a separate string, call [[get_label]]
to find a [[CMM_label]] for the label the string names, pop the string off the
Lua stack, call the appropriate Toolkit encoding function with the [[RAddr]],
and return 0 to signify they return no value to Lua.

<<bytecode generation>>=
int lua_CMM_cbrancht(lua_State *L) {
  const char *target;
  RAddr      addr;

  lua_assert_isstring(L, -1, "cbrancht requires target label");

  target = Atom_string(lua_tostring(L, -1));
  addr   = (get_label(L, target))->lbl.raddr;
  
  lua_pop(L, 1);

  /* emit instruction */
  cbrancht(addr);

  return 0;
}

int lua_CMM_cbranchf(lua_State *L) {
  const char *target;
  RAddr      addr;

  lua_assert_isstring(L, -1, "cbranchf requires target label");

  target = Atom_string(lua_tostring(L, -1));
  addr   = (get_label(L, target))->lbl.raddr;

  /* emit instruction */
  cbranchf(addr);

  return 0;
}
@ 

[[lua_CMM_branchtf]] is the same as its little siblings, except it expects two
strings (two labels) and makes two calls to [[get_label]].

<<bytecode generation>>=
int lua_CMM_branchtf(lua_State *L) {
  const char *targetT, *targetF;
  RAddr      addrT,    addrF;

  lua_assert_isstring(L, -1, "branchtf requires 2 target labels");
  lua_assert_isstring(L, -2, "branchtf requires 2 target labels");

  targetT = Atom_string(lua_tostring(L, -2));
  targetF = Atom_string(lua_tostring(L, -1));

  addrF   = (get_label(L, targetF))->lbl.raddr;
  addrT   = (get_label(L, targetT))->lbl.raddr;

  /* emit instruction */
  branchtf(addrT, addrF);

  return 0;
}
@ 

[[lua_CMM_call]] looks for three tables and a number (to be interpreted as a
boolean) atop the Lua stack, constructs an [[annotations]] structure from the
three tables and number, calls the [[cmm_call]] encoding function with a
pointer to the [[annotations]] structure, pops the four arguments off the Lua
stack, and returns 0 to tell Lua it returns no values.

<<bytecode generation>>=
int lua_CMM_call(lua_State *L) {
  int         n, t, i;
  annotations *ann;

  /* this function takes four arguments: 

     1. numerically-indexed, string table of "also cuts to" labels
     2. numerically-indexed, string table of "akso unwinds to" labels
     3. numerically-indexed, string table of "also returns to" labels
     4. number (0 or 1) indicating whether callee's activation may be "aborted"
   */
  lua_assert_isnumber(L, -1, 
                   "must specify whether called procedure may be aborted");
  lua_assert_istable(L, -2,
                   "must provide table of labels to which callee may return");
  lua_assert_istable(L, -3,
                   "must provide table of labels to which callee may unwind");
  lua_assert_istable(L, -4,
                   "must provide table of labels to which callee may cut");

  <<[[ann]] $\leftarrow$ new, initialized [[annotations]] structure>>

  /* emit instruction */
  call((unsigned) ann);  

  return 0;
}
@ 

Initializing the [[annotations]] structure is not too difficult, and ends up
popping all 4 arguments off the Lua stack in the process.
We use macros [[fresh_table]] and [[lua_pushtable]] for easy table
manipulation.

<<[[ann]] $\leftarrow$ new, initialized [[annotations]] structure>>=
ann = annotations_new();

ann->also_aborts = ((bool) lua_tonumber(L, -1));
lua_pop(L, 1);

ann->also_returns_to = fresh_table();
t = lua_gettop(L);
lua_pushtable(L, ann->also_returns_to);
<<convert labels in table at stack index [[t]] into [[CMM_label]]s in [[ann]]>>

ann->also_unwinds_to = fresh_table();
t = lua_gettop(L);
lua_pushtable(L, ann->also_unwinds_to);
<<convert labels in table at stack index [[t]] into [[CMM_label]]s in [[ann]]>>

ann->also_cuts_to = fresh_table();
t = lua_gettop(L);
lua_pushtable(L, ann->also_cuts_to);
<<convert labels in table at stack index [[t]] into [[CMM_label]]s in [[ann]]>>

ann->also_returns_to.L = ann->also_unwinds_to.L = ann->also_cuts_to.L = L;
@

Converting the labels stored in the argument tables into [[CMM_label]]s is as
simple as making calls to [[get_label]] and storing the returned
[[CMM_label]]s in a new [[table]] (in [[ann]]).

<<convert labels in table at stack index [[t]] into [[CMM_label]]s in [[ann]]>>=
  n = lua_getn(L, t);
  for (i = 1; i <= n; i++) {
    CMM_label *lbl;

    lua_rawgeti(L, t, i);
    lua_assert_isstring(L, -1, "annotations must be labels in string form");
    lbl = get_label(L, lua_tostring(L, -1));
    lua_pushusertag(L, (void *) lbl, lua_CMM_label_tag);
    lua_rawseti(L, -2, i);
  }
  lua_pop(L, 2); /* pop new table, pop argument table */
@
[[lua_CMM_cmm_return]] checks for two numbers atop the Lua stack, calls the
[[return_]] encoding function with the [[unsigned]] casts of these two numbers,
pops the numbers from the Lua stack, and returns 0 signifying that it returns
no values to Lua.
<<bytecode generation>>=
int lua_CMM_cmm_return (lua_State *L) {
  unsigned index, count;

  lua_assert_isnumber(L, -1, "return requires integer index and count!");
  lua_assert_isnumber(L, -2, "return requires integer index and count!");

  index = (unsigned) lua_tonumber(L, -2);
  count = (unsigned) lua_tonumber(L, -1);

  cmm_assert(index <= count, "return statement's index is not <= its count!");

  /* emit instruction */
  return_(index, count);

  lua_pop(L, 2);
  return 0;
}
@ 

And now we get to the wrappers that are macro-generated:

<<bytecode generation>>=
/* use : LUA_WRAP_NULLARY(encodingFunctionName, nameStemForLua) */
LUA_WRAP_NULLARY(goto_        , goto          )
LUA_WRAP_NULLARY(cmm_tail_call, cmm_tail_call )
LUA_WRAP_NULLARY(cut          , cut           )
LUA_WRAP_NULLARY(forbidden    , forbidden     )
LUA_WRAP_NULLARY(end_proc     , end_procedure )
LUA_WRAP_NULLARY(fetch_round  , fetch_rounding)
LUA_WRAP_NULLARY(store_round  , store_rounding)
LUA_WRAP_NULLARY(fetch_sp     , fetch_sp      )
LUA_WRAP_NULLARY(breakpt      , breakpt       )

/* use : LUA_WRAP_UNARY_INDEX(encodingFunctionName, nameStemForLua) */
LUA_WRAP_UNARY_INDEX(fetch_local  , fetch_local  )
LUA_WRAP_UNARY_INDEX(fetch_global , fetch_global )
LUA_WRAP_UNARY_INDEX(store_local  , store_local  )
LUA_WRAP_UNARY_INDEX(store_global , store_global )
LUA_WRAP_UNARY_INDEX(gstore_local , gstore_local )
LUA_WRAP_UNARY_INDEX(gstore_global, gstore_global)

/* use : LUA_WRAP_UNARY_ARGS(encodingFunctionName, nameStemForLua) */
LUA_WRAP_UNARY_ARGS( fetch_arg    , fetch_arg    )
LUA_WRAP_UNARY_ARGS( store_arg    , store_arg    )
@ 

Finally, one note about [[lua_CMM_breakpt]], as generated by
[[LUA_WRAP_NULLARY]].
It does not actually do anything, but we keep it as an encoded bytecode
instruction so we can more easily debug the implementation of [[run_interp]]
in [[interp.nw]].
We simply stick one in our source Lua code, set our favorite C debugger 
([[gdb]]) to break on its part of the big matching statement in [[run_interp]]
(in the [[interp]] module), and run.

% ----------------------------------------------------------------------------
\paragraph{Generating Prototypes}
% ----------------------------------------------------------------------------

Finally we generate the prototypes for the Lua-style encoding functions.

<<macro-generated function prototypes>>=
  ITERATE_CMM_FUNCS(LUA_FUNC_PROTOTYPE)
@ 
