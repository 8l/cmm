% -*- mode: Noweb; noweb-code-mode: c-mode -*- %

\ifx\nointro\undefined
This document contains the interface and implementation of a bytecode disassembler, used for debugging purposes.
\fi

% ----------------------------------------------------------------------------
\interface{[[disasm]] : Bytecode Disassembler}
% ----------------------------------------------------------------------------

<<disasm.h>>=
#ifndef _DISASM_H
#define _DISASM_H

#include <stdio.h>
#include "label.h"

<<function prototypes>>

#endif /* _DISASM_H */
@ 

[[disassemble_instructions]], which is a modified version of a disassembler 
automatically generated by the New Jersey Machine-Code Toolkit, disassembles 
the instruction bytecodes stored at a given location in memory and outputs the
disassembled code in readable format to file descriptor [[fd]].

[[disassemble_instruction]] is an internal function that helps to debug the
interpreter.  It simply disassembles the instruction at the given program
counter.  If this is the end of a procedure/halt/program, it returns NULL;
otherwise, it returns the next instruction.

<<function prototypes>>=
void disassemble_instructions(FILE *fd, CMM_label *loc);
unsigned char* disassemble_instruction(FILE *fd, unsigned char *pc);
@ 

To use this function, simply pass in a [[CMM_label]] referring to the place
in memory where you want it to begin disassembly.
It should plug right along without changing the contents of the memory being
disassembled.

Note that [[disassemble_instructions]] stops disassembly when it reaches
the end of a procedure or falls of a {\PAL} section.
If it is asked to disassemble code that includes initialized or uninitialized
{\PAL} data, bizarre results may occur (it will not be able to determine
the bit-widths of the data and may continue in some awful infinite loop).

% ----------------------------------------------------------------------------
\implementation{Bytecode Disassembler}
% ----------------------------------------------------------------------------

<<disasm.m>>=
#include "disasm.h"

#include <stdio.h>
#include <mclib.h>
#include "types.h"
#include "controlflow.h"
#include "operator.h"
#include "interp.h"
#include "machine.h"
#include "ccall.h"
#include "label.h"

static void print_procedure(FILE *fd, procedure *p) {
  if (p == NULL)
    asmprintf(fd, "<null>");
  else
    asmprintf(fd, "<Procedure>");
}
static void print_table(FILE *fd, table t) {
  if (t.data != LUA_REFNIL && t.data != LUA_NOREF)
    asmprintf(fd, "<Lua table #%d>", t.data);
  else
    asmprintf(fd, "<bogus value!!!>");
}
static void print_byteorder(FILE *fd, byte_order b) {
  switch (b) {
  case BIG:
    asmprintf(fd, "BIG_ENDIAN");
    break;
  case LITTLE:
    asmprintf(fd, "LITTLE_ENDIAN");
    break;
  default:
    asmprintf(fd, "<unknown byte_order>");
  }
}
static void print_unsigned_bits8(FILE *fd, unsigned /* [0..255] */ b8) {
  asmprintf(fd, "%u", b8);
}
static void print_unsigned_bits16(FILE *fd, unsigned /* [0..65535] */ b16) {
  
  asmprintf(fd, "%u", b16);
}
static void print_unsigned_bits32(FILE *fd, unsigned b32) {
  
  asmprintf(fd, "0x%x", b32);
}
static void disprintreloc(FILE *fd, unsigned a) {
  CMM_label *lbl = (CMM_label*)a; 

  asmprintf(fd, "<address 0x%x>", a);
  if (lbl->ty == CMM_PROCEDURE) {
    asmprintf(fd, " (proc %s)", lbl->lbl.proc->raddr->label->name);
  } else if (lbl->ty == CMM_LABEL) {
    asmprintf(fd, " (label %s)", lbl->lbl.raddr->label->name);
  } else if (lbl->ty == CMM_CFUNCTION) {
    lua_State    *L = c_func_table.L;

    lua_pushtable(L, c_func_table);
    lua_rawgeti(L, -1, lbl->lbl.cfunc_id);
    lua_pushstring(L, C_FUNC_NAME);
    lua_gettable(L, -2);
    if (lua_isstring(L, -1)) {
      asmprintf(fd, " (cfunc %s)", lua_tostring(L, -1));
    }
    lua_pop(L, 3);
  }
}

void disassemble_instructions(FILE *fd, CMM_label *loc) {
  unsigned char *pc = (unsigned char *) CMM_label_location(loc);

  if (fd == NULL) fd = stdout;

  while (pc) {
    pc = disassemble_instruction(fd, pc);
  }
}

unsigned char* disassemble_instruction(FILE *fd, unsigned char* pc) {
  unsigned char *next;

  match [next] pc to
  | APPLY_OPERATOR(op) =>
      {
        operator *o = (operator *) op;
        asmprintf(fd, "0x%x: %s", pc, "APPLY_OPERATOR ");
        asmprintf(fd, "{ name = \"%s\"", o->opname);
        asmprintf(fd, ", num_args = %u", o->num_args);
        asmprintf(fd, ", f = ");

        if (o->f) {
          asmprintf(fd, "<operator func>");
        } else {
	      asmprintf(fd, "<! INVALID !>"  );
        }

        asmprintf(fd, " }");
        asmprintf(fd, "\n");
      }
  | PUSH(b32, b8) => 
      asmprintf(fd, "0x%x: %s", pc, "PUSH ");
      print_unsigned_bits32(fd, b32);
      asmprintf(fd, " : width ");
      print_unsigned_bits8(fd, b8);
      asmprintf(fd, "\n");
  | PUSH_SYMBOL(a) =>
      asmprintf(fd, "0x%x: %s", pc, "PUSH_SYMBOL ");
      disprintreloc(fd, a);
      asmprintf(fd, "\n");
  | GSTORE(a, b, c) =>
      asmprintf(fd, "0x%x: %s", pc, "GSTORE ");
      print_unsigned_bits8(fd, a);
      asmprintf(fd, "%s", " ");
      print_byteorder(fd, b);
      asmprintf(fd, "%s", " ");
      print_unsigned_bits8(fd, c);
      asmprintf(fd, "\n");
  | FETCH(a, b, c) =>
      asmprintf(fd, "0x%x: %s", pc, "FETCH ");
      print_unsigned_bits8(fd, a);
      asmprintf(fd, "%s", " ");
      print_byteorder(fd, b);
      asmprintf(fd, "%s", " ");
      print_unsigned_bits8(fd, c);
      asmprintf(fd, "\n");
  | STORE(a, b, c) =>
      asmprintf(fd, "0x%x: %s", pc, "STORE ");
      print_unsigned_bits8(fd, a);
      asmprintf(fd, "%s", " ");
      print_byteorder(fd, b);
      asmprintf(fd, "%s", " ");
      print_unsigned_bits8(fd, c);
      asmprintf(fd, "\n");
  | FETCH_ARG(b8) => 
      asmprintf(fd, "0x%x: %s", pc, "FETCH_ARG ");
      print_unsigned_bits8(fd, b8);
      asmprintf(fd, "\n");
  | STORE_ARG(b8) => 
      asmprintf(fd, "0x%x: %s", pc, "STORE_ARG ");
      print_unsigned_bits8(fd, b8);
      asmprintf(fd, "\n");
  | STORE_LOCAL8(b8) => 
      asmprintf(fd, "0x%x: %s", pc, "STORE_LOCAL8 ");
      print_unsigned_bits8(fd, b8);
      asmprintf(fd, "\n");
  | STORE_GLOBAL8(b8) => 
      asmprintf(fd, "0x%x: %s", pc, "STORE_GLOBAL8 ");
      print_unsigned_bits8(fd, b8);
      asmprintf(fd, "\n");
  | FETCH_LOCAL8(b8) => 
      asmprintf(fd, "0x%x: %s", pc, "FETCH_LOCAL8 ");
      print_unsigned_bits8(fd, b8);
      asmprintf(fd, "\n");
  | FETCH_GLOBAL8(b8) => 
      asmprintf(fd, "0x%x: %s", pc, "FETCH_GLOBAL8 ");
      print_unsigned_bits8(fd, b8);
      asmprintf(fd, "\n");
  | STORE_LOCAL16(b16) => 
      asmprintf(fd, "0x%x: %s", pc, "STORE_LOCAL16 ");
      print_unsigned_bits16(fd, b16);
      asmprintf(fd, "\n");
  | STORE_GLOBAL16(b16) => 
      asmprintf(fd, "0x%x: %s", pc, "STORE_GLOBAL16 ");
      print_unsigned_bits16(fd, b16);
      asmprintf(fd, "\n");
  | FETCH_LOCAL16(b16) => 
      asmprintf(fd, "0x%x: %s", pc, "FETCH_LOCAL16 ");
      print_unsigned_bits16(fd, b16);
      asmprintf(fd, "\n");
  | FETCH_GLOBAL16(b16) => 
      asmprintf(fd, "0x%x: %s", pc, "FETCH_GLOBAL16 ");
      print_unsigned_bits16(fd, b16);
      asmprintf(fd, "\n");
  | GSTORE_LOCAL8(b8) => 
      asmprintf(fd, "0x%x: %s", pc, "GSTORE_LOCAL8 ");
      print_unsigned_bits8(fd, b8);
      asmprintf(fd, "\n");
  | GSTORE_LOCAL16(b16) => 
      asmprintf(fd, "0x%x: %s", pc, "GSTORE_LOCAL16 ");
      print_unsigned_bits16(fd, b16);
      asmprintf(fd, "\n");
  | GSTORE_GLOBAL8(b8) => 
      asmprintf(fd, "0x%x: %s", pc, "GSTORE_GLOBAL8 ");
      print_unsigned_bits8(fd, b8);
      asmprintf(fd, "\n");
  | GSTORE_GLOBAL16(b16) => 
      asmprintf(fd, "0x%x: %s", pc, "GSTORE_GLOBAL16 ");
      print_unsigned_bits16(fd, b16);
      asmprintf(fd, "\n");
  | GOTO() => 
      asmprintf(fd, "0x%x: %s", pc, "GOTO");
      asmprintf(fd, "\n");
  | CBRANCHT(a) => 
      asmprintf(fd, "0x%x: %s", pc, "CBRANCHT ");
      disprintreloc(fd, a);
      asmprintf(fd, "\n");
  | CBRANCHF(a) => 
      asmprintf(fd, "0x%x: %s", pc, "CBRANCHF ");
      disprintreloc(fd, a);
      asmprintf(fd, "\n");
  | BRANCHTF(a, b) => 
      asmprintf(fd, "0x%x: %s", pc, "BRANCHTF ");
      disprintreloc(fd, a);
      asmprintf(fd, "%s", " ");
      disprintreloc(fd, b);
      asmprintf(fd, "\n");
  | CALL(a) =>
      {
      annotations *ann = (annotations *) a;
      asmprintf(fd, "0x%x: %s", pc, "CALL ");
      asmprintf(fd, " { also cuts to = ");
      print_table(fd, ann->also_cuts_to);
      asmprintf(fd, ", also unwinds to = ");
      print_table(fd, ann->also_unwinds_to);
      asmprintf(fd, ", also returns to = ");
      print_table(fd, ann->also_returns_to);
      if (ann->also_aborts == 0) {
        asmprintf(fd, ", also aborts = false }");
      } else {
        asmprintf(fd, ", also aborts = true }");
      }
      asmprintf(fd, "\n");
      }
  | CMM_TAIL_CALL() => 
      asmprintf(fd, "0x%x: %s", pc, "CMM_TAIL_CALL");
      asmprintf(fd, "\n");
  | RETURN(a, b) => 
      asmprintf(fd, "0x%x: %s", pc, "RETURN ");
      print_unsigned_bits8(fd, a);
      asmprintf(fd, "%s", " ");
      print_unsigned_bits8(fd, b);
      asmprintf(fd, "\n");
  | CUT() => 
      asmprintf(fd, "0x%x: %s", pc, "CUT");
      asmprintf(fd, "\n");
  | DEFINE_PROC(a) =>
      asmprintf(fd, "0x%x: %s", pc, "PROCEDURE ");
      print_procedure(fd, (procedure *) a);
      asmprintf(fd, "\n");
  | END_PROC() =>
      asmprintf(fd, "0x%x: %s", pc, "END_PROCEDURE ");
      asmprintf(fd, "\n");
      return NULL;
  | FETCH_ROUND() =>
      asmprintf(fd, "0x%x: %s", pc, "FETCH ROUNDING MODE ");
      asmprintf(fd, "\n");
  | STORE_ROUND() => 
      asmprintf(fd, "0x%x: %s", pc, "STORE_ROUNDING MODE ");
      asmprintf(fd, "\n");
  | FETCH_SP() =>
      asmprintf(fd, "0x%x: %s", pc, "FETCH_SP ");
      asmprintf(fd, "\n");
  | BREAKPT() =>
      asmprintf(fd, "0x%x: %s", pc, "BREAKPT ");
      asmprintf(fd, "\n");
  | HALT =>
      return NULL;
  else {
         asmprintf(fd, "0x%x: <data: %x>\n", pc, *((u_int32 *) pc));
         next = pc + 4;
       }
  endmatch

  return next;
}
@
