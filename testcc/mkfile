# vim:ts=8 et sw=4:
#
# This directory contains code to test calling conventions. Code is
# generated by scripts:
#
#   call.pl:    - horrible script that emits one c-- file per signature
#
# To generate code and run the test, do the following:
#
#   mk
#   mk x86-test     if on x86
#   mk mips-test    if on MIPS (e.g., descartes)
#   mk alpha-test   if on Alpha (e.g., apple3, newcoke)
#
# If you need to run the tests on another machine, tarballs are created
# for your convenience (<architecture>-test.tar.gz).  Simply expand them
# and run the appropriate script (<architecture>.sh).
#

TOP      = ..
QC      = $TOP/bin/qc--.opt
QCFLAGS = -v backend.emit_data=nil
GEN      = ./call.pl
CC       = cc

ARCHS = ia64 x86

#
# The cmm-internal script generated an unknown number of files. Therefore
# I cannot list them here. I don't know how to organize compiling and
# testing them. 
#

# The following line can reach an internal mk(1) limit when the list of 
# C-- files is long. 
#
# ASM = `ls -1 *.c-- | sed s'/\.c--/.s/'`
# asm:V: $ASM
#
# Therefore I reverted to more explicit asm rules.

all:VQ:
  mk call ; mk asm ; mk tarballs

call:V: ${ARCHS:%=%-call}
asm :V: ${ARCHS:%=%-asm}

# A rule to pretty print a C-- source file

%.pp: %.c--
    $QC -pp $prereq

#
# A .sigs file contains lines of signatures for tests. Signatures are
# emitted by the QC-- compiler. You can enlarge the number of signatures
# by specifying more widths and hints to try. This only makes sense if
# they are actually implemented.
#

alpha-call.sigs:D:
  $QC tgt=Backend.alpha.target 'iwidths={64}' 'fwidths={64}' gensigs.lua > $target

x86-call.sigs:D:
  $QC tgt=Backend.x86.target 'iwidths={32}' 'fwidths={32, 64}' gensigs.lua > $target

mips-call.sigs:D:
  # no 64-bit anything because there is no block copy?
  $QC tgt=Backend.mips.target 'iwidths={32}' 'fwidths={32}' gensigs.lua > $target

ppc-call.sigs:D:
  $QC tgt=Backend.ppc.target 'iwidths={32}' 'fwidths={32, 64}' gensigs.lua > $target

ia64-call.sigs:D:
  $QC tgt=Backend.ia64.target 'iwidths={64}' 'fwidths={64}' gensigs.lua > $target

ppc-call.sigs:D:
  $QC tgt=Backend.ppc.target 'iwidths={32}' 'fwidths={32, 64}' gensigs.lua > $target

#
# Generate *.c-- files from one signature file. The test case generator
# must know about endianness, wordsize, and the base name of the test
# files.
#

alpha-call:V: alpha-call.sigs
               mkdir -p alpha ; cd alpha
               ../$GEN -name=alpha-i          -width=64 < ../$prereq
               ../$GEN -name=alpha-x      -c  -width=64 < ../$prereq

x86-call:V:   x86-call.sigs             
               mkdir -p x86 ; cd x86
               ../$GEN -name=x86-i            -width=32 < ../$prereq
               ../$GEN -name=x86-x        -c  -width=32 < ../$prereq

mips-call:V:  mips-call.sigs
               mkdir -p mips ; cd mips
               ../$GEN -name=mips-i           -width=32 < ../$prereq
               ../$GEN -name=mips-x       -c  -width=32 < ../$prereq

ia64-call:V:  ia64-call.sigs
               mkdir -p ia64 ; cd ia64
               ../$GEN -name=ia64-i           -width=64 < ../$prereq
               ../$GEN -name=ia64-x       -c  -width=64 < ../$prereq

ppc-call:V:  ppc-call.sigs
               mkdir -p ppc ; cd ppc
               ../$GEN -name=ppc-i           -width=32 < ../$prereq
               ../$GEN -name=ppc-x       -c  -width=32 < ../$prereq

#
# Compile *.c-- files to *.s code. Compilation depends on the desired
# target.
# 

X86_CMM    = x86*.c--
ALPHA_NUMS = 0 1 2 3 4 5 6 7
ALPHA_CMM  = ${ALPHA_NUMS:%=alpha\\[%]??.c--}
MIPS_CMM   = mips*.c--
IA64_NUMS  = 0 1 2 3 4 5 6 7 8 9
IA64_CMM   = ${IA64_NUMS:%=ia64\\?[%]??.c--}
PPC_CMM    = ppc*.c--

x86-asm:V:
    cd x86
	for f in "`echo "$X86_CMM" | tr ' ' '\n'`"; do
		../$QC -e 'Options.globals=2' backend=Backend.x86 $QCFLAGS \
	    	 -stop .s `echo $f`
	done

alpha-asm:V:
    cd alpha
    for f in $ALPHA_CMM; do
        PATTERN=`echo $f | tr '\\\\' '*'`
        FILES=`echo $PATTERN`
		../$QC -e 'Options.globals=2' backend=Backend.alpha $QCFLAGS \
              -stop .s $FILES
	done

mips-asm:V:
    cd mips
	for f in "`echo "$MIPS_CMM" | tr ' ' '\n'`" ; do
		../$QC -e 'Options.globals=2' backend=Backend.mips $QCFLAGS \
		 -stop .s `echo $f`
	done

ia64-asm:V:
    cd ia64
    for f in $IA64_CMM; do
        PATTERN=`echo $f | tr '\\\\' '*'`
        FILES=`echo $PATTERN`
        ../$QC -e 'Options.globals=2' backend=Backend.ia64 $QCFLAGS \
             -stop .s $FILES
    done

ppc-asm:V:
    cd ppc
	for f in "`echo "$PPC_CMM" | tr ' ' '\n'`"; do
		../$QC -e 'Options.globals=2' backend=Backend.ppc $QCFLAGS \
	    	 -stop .s `echo $f`
	done

alpha%.dbg: alpha%.c--
  $QC -e 'Options.globals=2' backend=Backend.alpha  \
       backend.asm=Asm.cmm -stop .s -o $target $prereq

#
# Run tests. This will only work on the right platform.
#

tarballs :V: ${ARCHS:%=%-test.tar.gz}
%-tarball:V: %-test.tar.gz

%-test.tar.gz: %/%.sh
  tar cf - $stem/ | gzip -c > $target

%-test:Q: %/%.sh
  cd $stem
  sh $stem.sh

x86/x86.sh:Q:
  echo '
  # set -x
  rm -f x86.log
  NFILES=`ls -1 x86*.s | wc -l`
  I=0
  if echo x86-i-*.s | grep -v \* > /dev/null; then
    for f in x86-i-*.s; do
      (cc $f && ./a.out) | tee -a x86.log | grep -v success
      I=$((I + 1))
      echo -n -e Finished $I of $NFILES tests: [ $((I * 100 / NFILES))% ]"\r"
    done
  fi
  if echo x86-x*-mn-*.s | grep -v \* > /dev/null; then
    for f in x86-x*-mn-*.s; do
      g=`echo $f | sed -e "s/mn/callee/" -e "s/\.s/\.c/"`
      (cc $f $g && ./a.out) | tee -a x86.log | grep -v success
      I=$((I + 1))
      echo -n -e Finished $I of $NFILES tests: [ $((I * 100 / NFILES))% ]"\r"
    done
  fi
  echo Completed testing x86 architecture.  Log file x86.log created.
  ' > $target  
  chmod +x $target

alpha/alpha.sh:Q:
  echo '
  # set -x
  rm -f alpha.log
  NFILES=`ls -1 alpha*.s | wc -l`
  I=0
  if echo alpha-i-*.s | grep -v \* > /dev/null; then
    for f in alpha-i-*.s; do
      (cc $f && ./a.out) | tee -a alpha.log | grep -v success
      I=$((I + 1))
      echo -n -e Finished $I of $NFILES tests: [ $((I * 100 / NFILES))% ]"\r"
    done
  fi
  if echo alpha-x*-mn-*.s | grep -v \* > /dev/null; then
    for f in alpha-x*-mn-*.s; do
      g=`echo $f | sed -e "s/mn/callee/" -e "s/\.s/\.c/"`
      (cc $f $g && ./a.out) | tee -a alpha.log | grep -v success
      I=$((I + 1))
      echo -n -e Finished $I of $NFILES tests: [ $((I * 100 / NFILES))% ]"\r"
    done   
  fi
  echo Completed testing Alpha architecture.  Log file alpha.log created.
  ' > $target
  chmod +x $target

mips/mips.sh:Q:
  echo '
  # set -x
  rm -f mips.log
  NFILES=`ls -1 mips*.s | wc -l`
  I=0
  if echo mips-i-*.s | grep -v \* > /dev/null; then
    for f in mips-i-*.s; do
      (cc -mno-abicalls -fno-pic -Wa,--no-warn $f && ./a.out) | \
        tee -a mips.log | grep -v success
      I=$((I + 1))
      echo -n -e Finished $I of $NFILES tests: [ $((I * 100 / NFILES))% ]"\r"
    done    
  fi
  if echo mips-x*-mn-*.s | grep -v \* > /dev/null; then
    for f in mips-x*-mn-*.s; do
      g=`echo $f | sed -e "s/mn/callee/" -e "s/\.s/\.c/"`
      (cc -Wa,--no-warn $f $g && ./a.out) | \
        tee -a mips.log | grep -v success
      I=$((I + 1))
      echo -n -e Finished $I of $NFILES tests: [ $((I * 100 / NFILES))% ]"\r"
    done
  fi
  echo Completed testing MIPS architecture.  Log file mips.log created.
  ' > $target
  chmod +x $target

ia64/ia64.sh:Q:
  echo '
  # set -x
  rm -f ia64.log
  NFILES=`ls -1 ia64*.s | wc -l`
  I=0
  if echo ia64-i-*.s | grep -v \* > /dev/null; then
    for f in ia64-i-*.s; do
      (cc $f && ./a.out) | tee -a ia64.log | grep -v success
      I=$((I + 1))
      echo -n -e Finished $I of $NFILES tests: [ $((I * 100 / NFILES))% ]"\r"
    done
  fi
  if echo ia64-x*-mn-*.s | grep -v \* > /dev/null; then
    for f in ia64-x*-mn-*.s; do
      g=`echo $f | sed -e "s/mn/callee/" -e "s/\.s/\.c/"`
      (cc $f $g && ./a.out) | tee -a ia64.log | grep -v success
      I=$((I + 1))
      echo -n -e Finished $I of $NFILES tests: [ $((I * 100 / NFILES))% ]"\r"
    done   
  fi
  echo Completed testing IA64 architecture.  Log file ia64.log created.
  ' > $target
  chmod +x $target

ia64-clean:V:
  rm -rf ia64/ ia64-call.sigs ia64-test.tar.gz

x86-clean:V:
  rm -rf x86/ x86-call.sigs x86-test.tar.gz

alpha-clean:V:
  rm -rf alpha/ alpha-call.sigs alpha-test.tar.gz

mips-clean:V:
  rm -rf mips/ mips-call.sigs mips-test.tar.gz

clean:V: ${ARCHS:%=%-clean}
   rm -f  *.dbg *.pp

clobber:V: clean
